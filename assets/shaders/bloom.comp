#version 460

// For upscale and mix phases we need to read current value of texture.
#if !defined(BLOOM_UPSCALE) && !defined(BLOOM_MIX)
layout (set = 0, binding = 0, rgba32f) writeonly uniform image2D outputTex;
#else
layout (set = 0, binding = 0, rgba32f) uniform image2D outputTex;
#endif // !BLOOM_UPSCALE
layout (set = 1, binding = 0) uniform sampler2D inputTex;

#if defined(BLOOM_FILTER)
layout (set = 2, binding = 0) uniform FilterParams
{
    float threshold;
    vec3 filterCurve;
} u_filter;
#endif

#if defined(BLOOM_DOWNSCALE) || defined(BLOOM_FILTER)
vec4 Downscale(ivec2 pixel)
{
    //vec2 texelSize = 1.f / textureSize(inputTex, 0);
    vec2 texelSize = 1.f / imageSize(outputTex);
    vec2 texCoords = vec2(pixel) * texelSize;
    texCoords += 0.5f*texelSize;

     // Take 13 samples around current texel:
    // a - b - c
    // - j - k -
    // d - e - f
    // - l - m -
    // g - h - i
    // === ('e' is the current texel) ===
    vec3 a = texture(inputTex, texCoords + vec2(-2.f * texelSize.x  , 2.f * texelSize.y)).rgb;
    vec3 b = texture(inputTex, texCoords + vec2(0.f                 , texelSize.y * 2.f)).rgb;
    vec3 c = texture(inputTex, texCoords + vec2(texelSize.x * 2.f   , texelSize.y * 2.f)).rgb;

    vec3 d = texture(inputTex, texCoords + vec2(texelSize.x * -2.f  , texelSize.y)).rgb;
    vec3 e = texture(inputTex, texCoords + vec2(texelSize.x         , texelSize.y)).rgb;
    vec3 f = texture(inputTex, texCoords + vec2(texelSize.x * 2.f   , texelSize.y)).rgb;

    vec3 g = texture(inputTex, texCoords + vec2(texelSize.x * -2.f  , texelSize.y * -2.f)).rgb;
    vec3 h = texture(inputTex, texCoords + vec2(texelSize.x         , texelSize.y * -2.f)).rgb;
    vec3 i = texture(inputTex, texCoords + vec2(texelSize.x * 2.f   , texelSize.y * -2.f)).rgb;

    vec3 j = texture(inputTex, texCoords + vec2(texelSize.x * -1.f  , texelSize.y * 1.f)).rgb;
    vec3 k = texture(inputTex, texCoords + vec2(texelSize.x * 1.f   , texelSize.y * 1.f)).rgb;
    vec3 l = texture(inputTex, texCoords + vec2(texelSize.x * -1.f  , texelSize.y * -1.f)).rgb;
    vec3 m = texture(inputTex, texCoords + vec2(texelSize.x * 1.f   , texelSize.y * -1.f)).rgb;

    // Apply weighted distribution:
    // 0.5 + 0.125 + 0.125 + 0.125 + 0.125 = 1
    // a,b,d,e * 0.125
    // b,c,e,f * 0.125
    // d,e,g,h * 0.125
    // e,f,h,i * 0.125
    // j,k,l,m * 0.5
    // This shows 5 square areas that are being sampled. But some of them overlap,
    // so to have an energy preserving downsample we need to make some adjustments.
    // The weights are the distributed, so that the sum of j,k,l,m (e.g.)
    // contribute 0.5 to the final color output. The code below is written
    // to effectively yield this sum. We get:
    // 0.125*5 + 0.03125*4 + 0.0625*4 = 1
    vec4 color = vec4(e*0.125f, 1.f);
    color += vec4((a+c+g+i)*0.03125f, 1.f);
    color += vec4((b+d+f+h)*0.0625f, 1.f);
    color += vec4((j+k+l+m)*0.125f, 1.f);
    //color = texture(u_tex, TexCoords);
    //color = vec4(texelSize, 0.f, 1.f);
    return color;
}
#endif

#ifdef BLOOM_UPSCALE
vec4 Upscale(ivec2 pixel, vec2 filterSize)
{
    // The filter kernel is applied with a radius, specified in texture
    // coordinates, so that the radius will vary across mip resolutions.
    vec2 texelSize = 1.f / vec2(imageSize(outputTex));
    vec2 texCoords = vec2(pixel) * texelSize;

    float x = filterSize.x * texelSize.x;
    float y = filterSize.y * texelSize.y;

    // Take 9 samples around current texel:
    // a - b - c
    // d - e - f
    // g - h - i
    // === ('e' is the current texel) ===
    vec3 a = texture(inputTex, vec2(texCoords.x - x, texCoords.y + y)).rgb;
    vec3 b = texture(inputTex, vec2(texCoords.x,     texCoords.y + y)).rgb;
    vec3 c = texture(inputTex, vec2(texCoords.x + x, texCoords.y + y)).rgb;

    vec3 d = texture(inputTex, vec2(texCoords.x - x, texCoords.y)).rgb;
    vec3 e = texture(inputTex, vec2(texCoords.x,     texCoords.y)).rgb;
    vec3 f = texture(inputTex, vec2(texCoords.x + x, texCoords.y)).rgb;

    vec3 g = texture(inputTex, vec2(texCoords.x - x, texCoords.y - y)).rgb;
    vec3 h = texture(inputTex, vec2(texCoords.x,     texCoords.y - y)).rgb;
    vec3 i = texture(inputTex, vec2(texCoords.x + x, texCoords.y - y)).rgb;

    // Apply weighted distribution, by using a 3x3 tent filter:
    //  1   | 1 2 1 |
    // -- * | 2 4 2 |
    // 16   | 1 2 1 |
    vec3 upsample = e*4.0;
    upsample += (b+d+f+h)*2.0;
    upsample += (a+c+g+i);
    upsample *= 1.0 / 16.0;
    return vec4(upsample, 1.f);
}
#endif

#ifdef BLOOM_FILTER
vec4 QuadraticThreshold(vec4 color, float threshold, vec3 curve)
{
    // max pixel brightness
    float brightness = max(max(color.r, color.g), color.b);
    float rq = clamp(brightness - curve.x, 0.f, curve.y);
    rq = (rq * rq) * curve.z;
    const float epsilon = 0.0001;
    color *= max(rq, brightness - threshold) / max(brightness, epsilon);
    return color;
}

vec4 FilterImage(ivec2 pixel, float threshold, vec3 curve)
{
    //vec2 texCoords = vec2(pixel) / textureSize(inputTex, 0);
    //vec4 color = texture(inputTex, texCoords);

    const float clampValue = 20.f;
    vec4 color = Downscale(pixel);
    color = clamp(color, vec4(0.f), vec4(clampValue));
    color = QuadraticThreshold(color, threshold, curve);

    if (!(color.r > threshold || color.g > threshold || color.b > threshold))
        color = vec4(0.f);
    return color;
}
#endif

layout (local_size_x = BLOOM_INVOCATIONS_X, local_size_y = BLOOM_INVOCATIONS_Y, local_size_z = 1) in;
void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 texSize = imageSize(outputTex);
    if (pixel.x >= texSize.x || pixel.y >= texSize.y)
        return;

#ifdef BLOOM_FILTER
    vec4 color = FilterImage(pixel, u_filter.threshold, u_filter.filterCurve);
    imageStore(outputTex, pixel, color);
#else 
#ifdef BLOOM_DOWNSCALE
    vec4 color = Downscale(pixel);
    imageStore(outputTex, pixel, color);
#else
#ifdef BLOOM_UPSCALE
    vec4 color = Upscale(pixel, vec2(1.f));
    vec4 base = imageLoad(outputTex, pixel);
    vec4 res = vec4(color.rgb + base.rgb, base.a);
    imageStore(outputTex, pixel, base + color);
#else
#ifdef BLOOM_MIX
    vec2 texCoords = vec2(pixel) / vec2(texSize);
    vec4 bloomColor = texture(inputTex, texCoords);
    vec4 sceneColor = imageLoad(outputTex, pixel);
    imageStore(outputTex, pixel, bloomColor + sceneColor);
#else
#error Specity bloom phase
#endif // BLOOM_MIX
#endif // BLOOM_UPSCALE
#endif // BLOOM_DOWNSCALE
#endif // BLOOM_FILTER


}



#if 0
vec4 Downscale(vec2 TexCoords, vec2 TexResolution)
{
    vec2 texelSize = 1.f / TexResolution;
    float x = texelSize.x;
    float y = texelSize.y;

    // Take 13 samples around current texel:
    // a - b - c
    // - j - k -
    // d - e - f
    // - l - m -
    // g - h - i
    // === ('e' is the current texel) ===
    vec3 a = texture(u_tex, vec2(TexCoords.x - 2*x, TexCoords.y + 2*y)).rgb;
    vec3 b = texture(u_tex, vec2(TexCoords.x,       TexCoords.y + 2*y)).rgb;
    vec3 c = texture(u_tex, vec2(TexCoords.x + 2*x, TexCoords.y + 2*y)).rgb;

    vec3 d = texture(u_tex, vec2(TexCoords.x - 2*x, TexCoords.y)).rgb;
    vec3 e = texture(u_tex, vec2(TexCoords.x,       TexCoords.y)).rgb;
    vec3 f = texture(u_tex, vec2(TexCoords.x + 2*x, TexCoords.y)).rgb;

    vec3 g = texture(u_tex, vec2(TexCoords.x - 2*x, TexCoords.y - 2*y)).rgb;
    vec3 h = texture(u_tex, vec2(TexCoords.x,       TexCoords.y - 2*y)).rgb;
    vec3 i = texture(u_tex, vec2(TexCoords.x + 2*x, TexCoords.y - 2*y)).rgb;

    vec3 j = texture(u_tex, vec2(TexCoords.x - x, TexCoords.y + y)).rgb;
    vec3 k = texture(u_tex, vec2(TexCoords.x + x, TexCoords.y + y)).rgb;
    vec3 l = texture(u_tex, vec2(TexCoords.x - x, TexCoords.y - y)).rgb;
    vec3 m = texture(u_tex, vec2(TexCoords.x + x, TexCoords.y - y)).rgb;

    // Apply weighted distribution:
    // 0.5 + 0.125 + 0.125 + 0.125 + 0.125 = 1
    // a,b,d,e * 0.125
    // b,c,e,f * 0.125
    // d,e,g,h * 0.125
    // e,f,h,i * 0.125
    // j,k,l,m * 0.5
    // This shows 5 square areas that are being sampled. But some of them overlap,
    // so to have an energy preserving downsample we need to make some adjustments.
    // The weights are the distributed, so that the sum of j,k,l,m (e.g.)
    // contribute 0.5 to the final color output. The code below is written
    // to effectively yield this sum. We get:
    // 0.125*5 + 0.03125*4 + 0.0625*4 = 1
    vec4 color = vec4(e*0.125, 1.f);
    color += vec4((a+c+g+i)*0.03125, 1.f);
    color += vec4((b+d+f+h)*0.0625, 1.f);
    color += vec4((j+k+l+m)*0.125, 1.f);
    //color = texture(u_tex, TexCoords);
    //color = vec4(texelSize, 0.f, 1.f);
    return color;
}

vec4 Upscale(vec2 TexCoords, float FilterRadius)
{
    // The filter kernel is applied with a radius, specified in texture
    // coordinates, so that the radius will vary across mip resolutions.
    float x = FilterRadius;
    float y = FilterRadius;

    // Take 9 samples around current texel:
    // a - b - c
    // d - e - f
    // g - h - i
    // === ('e' is the current texel) ===
    vec3 a = texture(u_tex, vec2(TexCoords.x - x, TexCoords.y + y)).rgb;
    vec3 b = texture(u_tex, vec2(TexCoords.x,     TexCoords.y + y)).rgb;
    vec3 c = texture(u_tex, vec2(TexCoords.x + x, TexCoords.y + y)).rgb;

    vec3 d = texture(u_tex, vec2(TexCoords.x - x, TexCoords.y)).rgb;
    vec3 e = texture(u_tex, vec2(TexCoords.x,     TexCoords.y)).rgb;
    vec3 f = texture(u_tex, vec2(TexCoords.x + x, TexCoords.y)).rgb;

    vec3 g = texture(u_tex, vec2(TexCoords.x - x, TexCoords.y - y)).rgb;
    vec3 h = texture(u_tex, vec2(TexCoords.x,     TexCoords.y - y)).rgb;
    vec3 i = texture(u_tex, vec2(TexCoords.x + x, TexCoords.y - y)).rgb;

    // Apply weighted distribution, by using a 3x3 tent filter:
    //  1   | 1 2 1 |
    // -- * | 2 4 2 |
    // 16   | 1 2 1 |
    vec3 upsample = e*4.0;
    upsample += (b+d+f+h)*2.0;
    upsample += (a+c+g+i);
    upsample *= 1.0 / 16.0;
    return vec4(upsample, 1.f);
}
#endif

