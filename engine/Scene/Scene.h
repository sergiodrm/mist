#pragma once
// Autogenerated code for Mist project
// Header file

//#include "Render/VulkanRenderEngine.h"
#include "Render/VulkanBuffer.h"
#include "Render/Texture.h"
#include "Render/Globals.h"
#include "Render/RenderAPI.h"
#include "Render/Mesh.h"
#include "Render/Material.h"
#include "Core/Types.h"
#include <glm/glm.hpp>

#define MIST_MAX_MATERIALS 50

namespace Mist
{
	struct RenderContext;
	struct RenderFrameContext;
	class IRenderEngine;
	class ShaderProgram;
	class DescriptorLayoutCache;
	class DescriptorAllocator;
	class Texture;

	struct sRenderObject
	{
		uint32_t Id = UINT32_MAX;
		sRenderObject() {}
		sRenderObject(uint32_t v) : Id(v) {}
		operator uint32_t() const { return Id; }
		inline bool IsValid() const { return Id != UINT32_MAX; }
	};


	enum class ELightType
	{
		Point,
		Directional,
		Spot
	};

	const char* LightTypeToStr(ELightType);
	ELightType StrToLightType(const char* str);

	struct LightComponent
	{
		ELightType Type = ELightType::Point;
		glm::vec3 Color = { 1.f, 1.f, 1.f };
		float Radius = 10.f;
		float Compression = 1.f;
		float InnerCutoff = 1.f;
		float OuterCutoff = 0.5f;
		bool ProjectShadows = false;
	};

	struct MeshComponent
	{
		char MeshAssetPath[256];
		std::string MeshName;
		uint32_t MeshIndex;

		MeshComponent() : MeshIndex(UINT32_MAX) { *MeshAssetPath = 0; }
	};

	struct Hierarchy
	{
		sRenderObject Parent;
		sRenderObject Sibling;
		sRenderObject Child;
		int32_t Level = 0;
	};

	struct TransformComponent
	{
		glm::vec3 Position;
		glm::vec3 Rotation;
		glm::vec3 Scale;
	};

	void TransformComponentToMatrix(const TransformComponent* transforms, glm::mat4* matrices, uint32_t count);

	struct LightData
	{
		union
		{
			glm::vec3 Position;
			glm::vec3 Direction;
		};
		union
		{
			float Radius;
			float ShadowMapIndex;
		};
		glm::vec3 Color;
		float Compression;
	};

	struct SpotLightData
	{
		glm::vec3 Color;
		float ShadowMapIndex;
		glm::vec3 Direction;
		float InnerCutoff;
		glm::vec3 Position;
		float OuterCutoff;
	};

	struct EnvironmentData
	{
		glm::vec3 AmbientColor;
		float ActiveSpotLightsCount;
		glm::vec3 ViewPosition;
		float ActiveLightsCount;
		static constexpr uint32_t MaxLights = 8;
		LightData Lights[MaxLights];
		LightData DirectionalLight;
		SpotLightData SpotLights[MaxLights];

		EnvironmentData();
	};

	struct Skybox
	{
		enum
		{
			FRONT, 
			BACK, 
			LEFT, 
			RIGHT, 
			TOP, 
			BOTTOM,
			COUNT
		};
		uint32_t MeshIndex;
		VkDescriptorSet CubemapSet;

		char CubemapFiles[COUNT][256];

		Skybox() : MeshIndex(UINT32_MAX), CubemapSet(VK_NULL_HANDLE) 
		{ 
			for (uint32_t i = 0; i < COUNT; ++i)
				*CubemapFiles[i] = 0;
		}
	};


	class Scene
	{

	protected:
		Scene(const Scene&) = delete;
		Scene(Scene&&) = delete;
		void operator=(const Scene&) = delete;
		void operator=(Scene&&) = delete;
	public:
		Scene(IRenderEngine* engine);
		~Scene();

		void Init();
		void Destroy();

		void InitFrameData(const RenderContext& renderContext, RenderFrameContext& frameContext);

		bool LoadModel(const RenderContext& context, const char* filepath);
		void LoadScene(const RenderContext& context, const char* filepath);
		void SaveScene(const RenderContext& context, const char* filepath);

		sRenderObject CreateRenderObject(sRenderObject parent);
		void DestroyRenderObject(sRenderObject object);
		bool IsValid(sRenderObject object) const;
		uint32_t GetRenderObjectCount() const;

		cMaterial* CreateMaterial(const char* name);
		cMaterial* GetMaterial(uint32_t index);
		const cMaterial* GetMaterial(uint32_t index) const;
		cMaterial* GetMaterial(const char* name);
		const cMaterial* GetMaterial(const char* name) const;


		sRenderObject GetRoot() const;
		const MeshComponent* GetMesh(sRenderObject renderObject) const;
		void SetMesh(sRenderObject renderObject, const MeshComponent& meshComponent);
		const char* GetRenderObjectName(sRenderObject object) const;
		void SetRenderObjectName(sRenderObject renderObject, const char* name);
		const TransformComponent& GetTransform(sRenderObject renderObject) const;
		void SetTransform(sRenderObject renderObject, const TransformComponent& transform);
		const LightComponent* GetLight(sRenderObject renderObject) const;
		void SetLight(sRenderObject renderObject, const LightComponent& light);
		void MarkAsDirty(sRenderObject renderObject);

		const glm::mat4* GetRawGlobalTransforms() const;

		const cMesh* GetMeshArray() const;
		uint32_t GetMeshCount() const;
		const cMesh* GetMeshRenderData(const char* meshId) const;
		cMesh* GetMeshRenderData(const char* meshId);
		const cMesh* GetMeshRenderData(const char* file, const char* meshname) const;
		cMesh* GetMeshRenderData(const char* file, const char* meshname);

		const cMaterial* GetMaterialArray() const;
		uint32_t GetMaterialCount() const;

		void UpdateRenderData(const RenderContext& renderContext, RenderFrameContext& frameContext);

		// Draw with materials
		void Draw(const RenderContext& context, ShaderProgram* shader, uint32_t materialSetIndex, uint32_t modelSetIndex, VkDescriptorSet modelSet) const;
		// Draw without materials
		void Draw(const RenderContext& context, ShaderProgram* shader, uint32_t modelSetIndex, VkDescriptorSet modelSet) const;
		void DrawSkybox(CommandBuffer cmd, ShaderProgram* shader);

		void ImGuiDraw();
		bool IsDirty() const;
		const EnvironmentData& GetEnvironmentData() const { return m_environmentData; }
	protected:
		void ProcessEnvironmentData(const glm::mat4& viewMatrix, EnvironmentData& environmentData);
		void RecalculateTransforms();
		bool LoadMeshesFromFile(const RenderContext& context, const char* filepath);
		bool LoadSkybox(const RenderContext& context, Skybox& skybox, const char* front, const char* back, const char* left, const char* right, const char* top, const char* bottom);

	private:
		class VulkanRenderEngine* m_engine{nullptr};
		static constexpr uint32_t MaxNodeLevel = 16;
		tDynArray<tString> m_names;
		tDynArray<tString> m_materialNames;
		tDynArray<Hierarchy> m_hierarchy;
		tDynArray<TransformComponent> m_transformComponents;
		tMap<uint32_t, MeshComponent> m_meshComponentMap;
		tMap<uint32_t, LightComponent> m_lightComponentMap;
		tDynArray<cMaterial> m_materialArray;
		tDynArray<uint32_t> m_dirtyMaterials;

		tDynArray<glm::mat4> m_localTransforms;
		tDynArray<glm::mat4> m_globalTransforms;
		
		tDynArray<int32_t> m_dirtyNodes[MaxNodeLevel];

		tDynArray<cMesh> m_meshes;
		tDynArray<Texture*> m_textures;
		glm::vec3 m_ambientColor = {0.05f, 0.05f, 0.05f};

		tMap<tString, uint32_t> m_meshNameIndexMap;
		Skybox m_skybox;
		uint32_t m_defaultMaterialIndex = 0;
		tArray<VkDescriptorSet, globals::MaxOverlappedFrames> m_materialSetArray;
		EnvironmentData m_environmentData;
	};
}
