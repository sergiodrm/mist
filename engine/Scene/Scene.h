#pragma once
// Autogenerated code for Mist project
// Header file

//#include "Render/VulkanRenderEngine.h"
#include "Render/VulkanBuffer.h"
#include "Render/Texture.h"
#include "Render/Globals.h"
#include "Render/RenderAPI.h"
#include "Render/Model.h"
#include "Render/Material.h"
#include "Core/Types.h"
#include <glm/glm.hpp>
#include "Utils/Angles.h"

#define MIST_MAX_MODELS 128

namespace Mist
{
	struct RenderContext;
	struct RenderFrameContext;
	class IRenderEngine;
	class ShaderProgram;
	class DescriptorLayoutCache;
	class DescriptorAllocator;
	class cTexture;
	class cModel;

	struct sRenderObject
	{
		index_t Id = index_invalid;
		sRenderObject() {}
		sRenderObject(index_t v) : Id(v) {}
		operator index_t() const { return Id; }
		inline bool IsValid() const { return Id != index_invalid; }
	};


	enum class ELightType
	{
		Point,
		Directional,
		Spot
	};

	const char* LightTypeToStr(ELightType);
	ELightType StrToLightType(const char* str);

	struct LightComponent
	{
		ELightType Type = ELightType::Point;
		glm::vec3 Color = { 1.f, 1.f, 1.f };
		float Radius = 10.f;
		float Compression = 1.f;
		float OuterCutoff = 30.f;	// Degrees
		float Cutoff = 30.f;			// Degrees
		bool ProjectShadows = false;
	};

	struct MeshComponent
	{
		char MeshAssetPath[256];
		uint32_t MeshIndex;

		MeshComponent() : MeshIndex(UINT32_MAX) { *MeshAssetPath = 0; }
	};

	struct Hierarchy
	{
		sRenderObject Parent;
		sRenderObject Sibling;
		sRenderObject Child;
		int32_t Level = 0;
	};

	struct TransformComponent
	{
		glm::vec3 Position;
		tAngles Rotation;
		glm::vec3 Scale;
	};

	void TransformComponentToMatrix(const TransformComponent* transforms, glm::mat4* matrices, uint32_t count);

	struct LightData
	{
		glm::vec3 Color;
		float Compression;

		glm::vec3 Position;
		float Radius;

		glm::vec3 Direction;
		int Type;

		glm::vec2 CosCutoff;
		int ShadowMapIndex;
		float _padding;
	};

	struct tShadowMapData
	{
		glm::mat4 LightViewMatrices[globals::MaxShadowMapAttachments];
	};

	struct EnvironmentData
	{
		glm::vec3 AmbientColor;
		int ActiveSpotLightsCount;
		glm::vec3 ViewPosition;
		int ActiveLightsCount;
		static constexpr uint32_t MaxLights = 8;
		LightData Lights[MaxLights];
		LightData DirectionalLight;
		LightData SpotLights[MaxLights];

		EnvironmentData();
	};

	struct CameraData
	{
		glm::mat4 InvView;
		glm::mat4 Projection;
		glm::mat4 ViewProjection;
	};

	struct tViewRenderInfo
	{
		// View info
		CameraData view;

		// Shadow map
		uint32_t shadowMapTexturesSlot;
		tShadowMapData shadowMap;
		const cTexture* shadowMapTextures[globals::MaxShadowMapAttachments];

		// Scene info
		EnvironmentData environment;

		uint32_t cubemapSlot;
		const cTexture* cubemap;

		// Render flags
		uint16_t flags;
	};

	struct Skybox
	{
		enum
		{
			FRONT, 
			BACK, 
			TOP, 
			BOTTOM,
			RIGHT, 
			LEFT, 
			COUNT
		};
		cTexture* Tex;
		char CubemapFiles[COUNT][256];

		Skybox()
		{ 
			Tex = nullptr;
			for (uint32_t i = 0; i < COUNT; ++i)
				*CubemapFiles[i] = 0;
		}
	};

	class Scene
	{

	protected:
		Scene(const Scene&) = delete;
		Scene(Scene&&) = delete;
		void operator=(const Scene&) = delete;
		void operator=(Scene&&) = delete;
	public:
		Scene(IRenderEngine* engine);
		~Scene();

		void Init();
		void Destroy();

		void InitFrameData(const RenderContext& renderContext, RenderFrameContext& frameContext);

		void LoadScene(const RenderContext& context, const char* filepath);
		void SaveScene(const RenderContext& context, const char* filepath);

		sRenderObject CreateRenderObject(sRenderObject parent);
		void DestroyRenderObject(sRenderObject object);
		bool IsValid(sRenderObject object) const;
		uint32_t GetRenderObjectCount() const;

		sRenderObject GetRoot() const;

		const MeshComponent* GetMesh(sRenderObject renderObject) const;
		void SetMesh(sRenderObject renderObject, const MeshComponent& meshComponent);

		const char* GetRenderObjectName(sRenderObject object) const;
		void SetRenderObjectName(sRenderObject renderObject, const char* name);

		const TransformComponent& GetTransform(sRenderObject renderObject) const;
		void SetTransform(sRenderObject renderObject, const TransformComponent& transform);

		const LightComponent* GetLight(sRenderObject renderObject) const;
		void SetLight(sRenderObject renderObject, const LightComponent& light);

		void MarkAsDirty(sRenderObject renderObject);

		const glm::mat4* GetRawGlobalTransforms() const;

		void UpdateRenderData(const RenderContext& renderContext, RenderFrameContext& frameContext);
		
		void Draw(const RenderContext& context, ShaderProgram* shader, uint32_t materialSetIndex, uint32_t modelSetIndex, VkDescriptorSet modelSet, uint16_t renderFlags = 0) const;
		void DrawWithMaterials(const RenderContext& context, const tViewRenderInfo& viewRenderInfo, uint32_t textureSlot) const;
		// can be nullptr
		const cTexture* GetSkyboxTexture() const;

		void ImGuiDraw();
		bool IsDirty() const;
		const EnvironmentData& GetEnvironmentData() const { return m_environmentData; }
	protected:
		void ProcessEnvironmentData(const glm::mat4& viewMatrix, EnvironmentData& environmentData);
		void RecalculateTransforms();
		bool LoadMeshesFromFile(const RenderContext& context, const char* filepath);
		bool LoadSkybox(const RenderContext& context, Skybox& skybox, const char* front, const char* back, const char* left, const char* right, const char* top, const char* bottom);

		const cModel* GetModel(const char* modelName) const { return const_cast<Scene*>(this)->GetModel(modelName); }
		cModel* GetModel(const char* modelName);
		index_t LoadModel(const RenderContext& context, const char* filepath);

	private:
		class VulkanRenderEngine* m_engine{nullptr};
		static constexpr index_t MaxNodeLevel = 16;
		tDynArray<tString> m_names;
		tDynArray<Hierarchy> m_hierarchy;
		tDynArray<TransformComponent> m_transformComponents;
		tMap<index_t, MeshComponent> m_meshComponentMap;
		tMap<index_t, LightComponent> m_lightComponentMap;

		tStaticArray<cModel, MIST_MAX_MODELS> m_models;

		tDynArray<glm::mat4> m_localTransforms;
		tDynArray<glm::mat4> m_globalTransforms;
		tDynArray<glm::mat4> m_renderTransforms;
		tDynArray<sMaterialRenderData> m_materials;
		tMap<index_t, index_t> m_modelMaterialMap;
		index_t m_editingModel = index_invalid;
		
		tDynArray<index_t> m_dirtyNodes[MaxNodeLevel];

		glm::vec3 m_ambientColor = {0.05f, 0.05f, 0.05f};

		Skybox m_skybox;
		EnvironmentData m_environmentData;
	};
}
