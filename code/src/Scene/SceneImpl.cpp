// Autogenerated code for Mist project
// Source file
#include "SceneImpl.h"
#include "Core/Logger.h"
#include "Core/Debug.h"

#define CGLTF_IMPLEMENTATION
#pragma warning(disable:4996)
#include <gltf/cgltf.h>
#undef CGLTF_IMPLEMENTATION

#ifdef MIST_MEM_MANAGEMENT
// TODO: wtf windows declare these macros and project does not compile when MIST_MEM_MANAGEMENT is defined. WTF!?
#undef min
#undef max  
#endif // MIST_MEM_MANAGEMENT

#include <glm/gtx/transform.hpp>
#include <glm/gtx/quaternion.hpp>
#include <glm/gtx/euler_angles.hpp>
#include <glm/fwd.hpp>
#include "Render/Mesh.h"
#include "Utils/GenericUtils.h"
#include "Render/VulkanRenderEngine.h"
#include <algorithm>
#include <imgui.h>

#define SCENE_LOAD_YAML
#ifdef SCENE_LOAD_YAML

#include <yaml-cpp/yaml.h>

#endif // SCENE_LOAD_YAML
#include <fstream>

//#define MIST_ENABLE_LOADER_LOG

#ifdef SCENE_LOAD_YAML
YAML::Emitter& operator<<(YAML::Emitter& e, const glm::vec3& v)
{
	e << YAML::Flow << YAML::BeginSeq << v.x << v.y << v.z << YAML::EndSeq;
	return e;
}

YAML::Emitter& operator<<(YAML::Emitter& e, const glm::vec4& v)
{
	e << YAML::Flow << YAML::BeginSeq << v.x << v.y << v.z << v.w << YAML::EndSeq;
	return e;
}

namespace YAML
{
	template<>
	struct convert<glm::vec2>
	{
		static Node encode(const glm::vec2& rhs)
		{
			Node node;
			node.push_back(rhs.x);
			node.push_back(rhs.y);
			return node;
		}

		static bool decode(const Node& node, glm::vec2& rhs)
		{
			if (!node.IsSequence() || node.size() != 2)
				return false;

			rhs.x = node[0].as<float>();
			rhs.y = node[1].as<float>();
			return true;
		}
	};

	template<>
	struct convert<glm::vec3>
	{
		static Node encode(const glm::vec3& rhs)
		{
			Node node;
			node.push_back(rhs.x);
			node.push_back(rhs.y);
			node.push_back(rhs.z);
			return node;
		}

		static bool decode(const Node& node, glm::vec3& rhs)
		{
			if (!node.IsSequence() || node.size() != 3)
				return false;

			rhs.x = node[0].as<float>();
			rhs.y = node[1].as<float>();
			rhs.z = node[2].as<float>();
			return true;
		}
	};
}

#endif

#define GLTF_LOAD_GEOMETRY_POSITION 0x01
#define GLTF_LOAD_GEOMETRY_NORMAL 0x02
#define GLTF_LOAD_GEOMETRY_COLOR 0x04
#define GLTF_LOAD_GEOMETRY_TANGENT 0x08
#define GLTF_LOAD_GEOMETRY_TEXCOORDS 0x10
#define GLTF_LOAD_GEOMETRY_JOINTS 0x20
#define GLTF_LOAD_GEOMETRY_WEIGHTS 0x40
#define GLTF_LOAD_GEOMETRY_ALL 0xff

namespace gltf_api
{
	void HandleError(cgltf_result result, const char* filepath)
	{
		switch (result)
		{
		case cgltf_result_success:
			break;
		case cgltf_result_data_too_short:
			break;
		case cgltf_result_unknown_format:
			break;
		case cgltf_result_invalid_json:
			break;
		case cgltf_result_invalid_gltf:
			break;
		case cgltf_result_invalid_options:
			break;
		case cgltf_result_file_not_found:
			break;
		case cgltf_result_io_error:
			break;
		case cgltf_result_out_of_memory:
			break;
		case cgltf_result_legacy_gltf:
			break;
		case cgltf_result_max_enum:
			break;
		default:
			break;
		}
	}

	float Length2(const glm::vec3& vec)
	{
		return vec.x * vec.x + vec.y * vec.y + vec.z * vec.z;
	}

	float Length(const glm::vec3& vec) { return sqrtf(Length2(vec)); }

	uint32_t GetElementCountFromType(cgltf_type type)
	{
		switch (type)
		{
		case cgltf_type_scalar: return 1;
		case cgltf_type_vec2: return 2;
		case cgltf_type_vec3: return 3;
		case cgltf_type_vec4: return 4;
		case cgltf_type_mat2: return 2 * 2;
		case cgltf_type_mat3: return 3 * 3;
		case cgltf_type_mat4: return 4 * 4;
		case cgltf_type_invalid:
		case cgltf_type_max_enum:
		default:
			check(false && "Invalid cgltf_type.");
			break;
		}
		return 0;
	}

	void ReadValue(void* dst, const cgltf_float* data, uint32_t count)
	{
		memcpy_s(dst, sizeof(float) * count, data, sizeof(float) * count);
	}

	void ToMat4(glm::mat4* mat, const cgltf_float* cgltfMat4)
	{
		ReadValue(mat, cgltfMat4, 16);
	}

	void ToVec2(glm::vec2& v, const cgltf_float* data)
	{
		ReadValue(&v, data, 2);
	}

	void ToVec3(glm::vec3& v, const cgltf_float* data)
	{
		ReadValue(&v, data, 3);
	}

	void ToVec4(glm::vec4& v, const cgltf_float* data)
	{
		ReadValue(&v, data, 4);
	}

	void ToQuat(glm::quat& q, const cgltf_float* data)
	{
		q = glm::quat(data[3], data[0], data[1], data[2]);
	}

	void ReadNodeLocalTransform(const cgltf_node& node, glm::mat4& t)
	{
		if (node.has_matrix)
		{
			gltf_api::ToMat4(&t, node.matrix);
		}
		else
		{
			if (node.has_translation)
			{
				glm::vec3 pos;
				gltf_api::ToVec3(pos, node.translation);
				t = glm::translate(t, pos);
			}
			if (node.has_rotation)
			{
				glm::quat quat;
				gltf_api::ToQuat(quat, node.rotation);
				t *= glm::toMat4(quat);
			}
			if (node.has_scale)
			{
				glm::vec3 scl;
				gltf_api::ToVec3(scl, node.scale);
				t = glm::scale(t, scl);
			}
		}
	}

	void ReadValues(std::vector<float>& values, const cgltf_accessor& accessor)
	{
		uint32_t elementCount = GetElementCountFromType(accessor.type);
		values.resize(accessor.count * elementCount);
		for (uint32_t i = 0; i < accessor.count; ++i)
			cgltf_accessor_read_float(&accessor, i, &values[i * elementCount], elementCount);
	}

	void ReadAttribute(Mist::Vertex& vertex, const float* source, uint32_t index, cgltf_attribute_type type)
	{
		const char* attributeName = nullptr;
		const float* data = &source[index];
		switch (type)
		{
		case cgltf_attribute_type_position:
			ToVec3(vertex.Position, data);
			break;
		case cgltf_attribute_type_texcoord:
			ToVec2(vertex.TexCoords, data);
			break;
		case cgltf_attribute_type_normal:
			ToVec3(vertex.Normal, data);
			if (Length2(vertex.Normal) < 1e-5f)
				vertex.Normal = glm::vec3{ 0.f, 1.f, 0.f };
			else
				vertex.Normal = glm::normalize(vertex.Normal);
			break;
		case cgltf_attribute_type_color:
			ToVec3(vertex.Color, data);
			break;
		case cgltf_attribute_type_tangent:
			ToVec3(vertex.Tangent, data);
			break;
		case cgltf_attribute_type_joints:
#ifdef MIST_ENABLE_LOADER_LOG
			attributeName = "joints";
#endif // MIST_ENABLE_LOADER_LOG

			break;
		case cgltf_attribute_type_weights:
#ifdef MIST_ENABLE_LOADER_LOG
			attributeName = "weights";
#endif // MIST_ENABLE_LOADER_LOG
			break;
		case cgltf_attribute_type_invalid:
		case cgltf_attribute_type_custom:
		case cgltf_attribute_type_max_enum:
			check(false && "Invalid attribute type to read.");
		default:
			break;
		}
#ifdef MIST_ENABLE_LOADER_LOG
		if (attributeName)
			Mist::Logf(Mist::LogLevel::Error, "gltf loader: Attribute type not suported yet [%s].\n", attributeName);
#endif // MIST_ENABLE_LOADER_LOG

	}

	// Attributes are an continuous array of positions, normals, uvs...
	// We have to map from struct of arrays to our format, array of structs (std::vector<Mist::Vertex>)
	void ReadAttributeArray(Mist::Vertex* vertices, const cgltf_attribute& attribute, const cgltf_node* nodes, uint32_t nodeCount)
	{
		const cgltf_accessor* accessor = attribute.data;
		uint32_t accessorCount = (uint32_t)accessor->count;
		// Get how many values has current attribute
		uint32_t elementCount = GetElementCountFromType(accessor->type);
		// Read data from accessor
		std::vector<float> values;
		ReadValues(values, *accessor);
		// Map to internal format
		for (uint32_t i = 0; i < accessorCount; ++i)
		{
			Mist::Vertex& vertex = vertices[i];
			uint32_t indexValue = i * elementCount;
			ReadAttribute(vertex, values.data(), indexValue, attribute.type);
		}
	}

	void FreeData(cgltf_data* data)
	{
		cgltf_free(data);
	}

	cgltf_data* ParseFile(const char* filepath)
	{
		cgltf_options options;
		memset(&options, 0, sizeof(cgltf_options));
		cgltf_data* data{ nullptr };
		cgltf_result result = cgltf_parse_file(&options, filepath, &data);
		if (result != cgltf_result_success)
		{
			HandleError(result, filepath);
			return nullptr;
		}
		result = cgltf_load_buffers(&options, data, filepath);
		if (result != cgltf_result_success)
		{
			HandleError(result, filepath);
			return nullptr;
		}
		result = cgltf_validate(data);
		if (result != cgltf_result_success)
		{
			HandleError(result, filepath);
			FreeData(data);
			return nullptr;
		}
		return data;
	}

	void LoadVertices(std::vector<Mist::Vertex>& vertices, const cgltf_primitive* primitive, const cgltf_node* nodes, uint32_t nodeCount)
	{
		uint32_t attributeCount = (uint32_t)primitive->attributes_count;
		uint32_t vertexOffset = (uint32_t)vertices.size();
		uint32_t vertexCount = (uint32_t)primitive->attributes[0].data->count;
		vertices.resize(vertexCount + vertexOffset);
		for (uint32_t i = 0; i < attributeCount; ++i)
		{
			const cgltf_attribute& attribute = primitive->attributes[i];
			check(attribute.data->count == vertexCount);
			ReadAttributeArray(vertices.data() + vertexOffset, attribute, nodes, nodeCount);
		}
	}

	void LoadIndices(std::vector<uint32_t>& indices, const cgltf_primitive* primitive, uint32_t offset)
	{
		check(primitive->indices);
		uint32_t indexCount = (uint32_t)primitive->indices->count;
		uint32_t indexOffset = (uint32_t)indices.size();
		indices.resize(indexCount + indexOffset);
		for (uint32_t i = 0; i < indexCount; ++i)
			indices[i + indexOffset] = (uint32_t)cgltf_accessor_read_index(primitive->indices, i) + offset;
	}

	bool LoadTexture(const Mist::RenderContext& context, const char* rootAssetPath, const cgltf_texture_view& texView, Mist::EFormat format, Mist::Texture** texOut)
	{
		char texturePath[512];
		sprintf_s(texturePath, "%s%s", rootAssetPath, texView.texture->image->uri);
		return Mist::LoadTextureFromFile(context, texturePath, texOut, format);
	}

	void LoadMaterial(const Mist::RenderContext& context, Mist::Scene& scene, const char* rootAssetPath, Mist::Material& material, const cgltf_material& mtl)
	{
		check(mtl.name);
		material.SetName(mtl.name);
		if (mtl.pbr_metallic_roughness.base_color_texture.texture)
		{
			Mist::Texture* diffuse;
			check(LoadTexture(context,
				rootAssetPath,
				mtl.pbr_metallic_roughness.base_color_texture, Mist::FORMAT_R8G8B8A8_SRGB, &diffuse));
			Mist::RenderHandle h = scene.SubmitTexture(diffuse);
			material.SetAlbedoTexture(h);
		}
		else
		{
#ifdef MIST_ENABLE_LOADER_LOG
			Mist::Log(Mist::LogLevel::Warn, "Diffuse material texture not found.\n");
#endif // MIST_ENABLE_LOADER_LOG
		}
		if (mtl.pbr_metallic_roughness.metallic_roughness_texture.texture)
		{
			Mist::Texture* diffuse;
			check(LoadTexture(context,
				rootAssetPath,
				mtl.pbr_metallic_roughness.metallic_roughness_texture, Mist::FORMAT_R8G8B8A8_SRGB, &diffuse));
			Mist::RenderHandle h = scene.SubmitTexture(diffuse);
			material.SetMetallicTexture(h);
		}
		else
		{
#ifdef MIST_ENABLE_LOADER_LOG
			Mist::Log(Mist::LogLevel::Warn, "Diffuse material texture not found.\n");
#endif // MIST_ENABLE_LOADER_LOG
		}
		material.SetMetallic(mtl.pbr_metallic_roughness.metallic_factor);
		material.SetRoughness(mtl.pbr_metallic_roughness.roughness_factor);

		if (mtl.pbr_specular_glossiness.diffuse_texture.texture)
		{
			Mist::Texture* tex;
			check(LoadTexture(context,
				rootAssetPath,
				mtl.pbr_specular_glossiness.diffuse_texture, Mist::FORMAT_R8G8B8A8_UNORM, &tex));
			Mist::RenderHandle h = scene.SubmitTexture(tex);
			material.SetSpecularTexture(h);
		}
#ifdef MIST_ENABLE_LOADER_LOG
		else
			Mist::Log(Mist::LogLevel::Warn, "Specular material texture not found.\n");
#endif // MIST_ENABLE_LOADER_LOG

		if (mtl.normal_texture.texture)
		{
			Mist::Texture* tex;
			check(LoadTexture(context,
				rootAssetPath,
				mtl.normal_texture, Mist::FORMAT_R8G8B8A8_UNORM, &tex));
			Mist::RenderHandle h = scene.SubmitTexture(tex);
			material.SetNormalTexture(h);
		}
#ifdef MIST_ENABLE_LOADER_LOG
		else
			Mist::Log(Mist::LogLevel::Warn, "Normal material texture not found.\n");
#endif // MIST_ENABLE_LOADER_LOG

		if (mtl.occlusion_texture.texture)
		{
			Mist::Texture* tex;
			check(LoadTexture(context, rootAssetPath, mtl.occlusion_texture, Mist::FORMAT_R8G8B8A8_UNORM, &tex));
			Mist::RenderHandle h = scene.SubmitTexture(tex);
			material.SetOcclusionTexture(h);
		}
#ifdef MIST_ENABLE_LOADER_LOG
		else
			Mist::Log(Mist::LogLevel::Warn, "Occlusion material texture not found.\n");
#endif // MIST_ENABLE_LOADER_LOG
	}

	void LoadGeometry(Mist::Mesh& mesh, Mist::tDynArray<Mist::PrimitiveMeshData>& primitives, const std::unordered_map<cgltf_material*, uint32_t>& materialMap, const cgltf_node& node, const cgltf_data& scene)
	{
		check(node.mesh && node.mesh->name);
		mesh.SetName(node.mesh->name);

		Mist::tDynArray<Mist::Vertex> vertices;
		Mist::tDynArray<uint32_t> indices;
		primitives.resize(node.mesh->primitives_count);

		for (uint32_t j = 0; j < node.mesh->primitives_count; ++j)
		{
			const cgltf_primitive& primitive = node.mesh->primitives[j];
			uint32_t vertexOffset = (uint32_t)vertices.size();
			primitives[j].FirstIndex = (uint32_t)indices.size();
			gltf_api::LoadIndices(indices, &primitive, vertexOffset);
			gltf_api::LoadVertices(vertices, &primitive, scene.nodes, (uint32_t)scene.nodes_count);
			primitives[j].Count = (uint32_t)indices.size() - primitives[j].FirstIndex;
			check(materialMap.contains(primitive.material));
			primitives[j].MaterialIndex = materialMap.at(primitive.material);
			check(primitive.indices->count == primitives[j].Count);
		}

		// Sort primitives by index
		std::sort(primitives.begin(), primitives.end(),
			[](const Mist::PrimitiveMeshData& a, const Mist::PrimitiveMeshData& b) {return a.MaterialIndex < b.MaterialIndex; }
		);

		mesh.MoveIndicesFrom(indices);
		mesh.MoveVerticesFrom(vertices);
	}
}

namespace Mist
{
	void MeshRenderData::BindBuffers(VkCommandBuffer cmd) const
	{
		VertexBuffer.Bind(cmd);
		IndexBuffer.Bind(cmd);
	}

	VkDescriptorSetLayout MaterialRenderData::GetDescriptorSetLayout(const RenderContext& renderContext)
	{
		VkDescriptorSetLayout layout;
		DescriptorSetLayoutBuilder::Create(*renderContext.LayoutCache)
			.AddBinding(0, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT, 6)
			.Build(renderContext, &layout);
		return layout;
	}

	void MaterialRenderData::Init(const RenderContext& renderContext)
	{
		check(Layout == VK_NULL_HANDLE);
		DescriptorAllocator& descAllocator = *renderContext.DescAllocator;
		DescriptorLayoutCache& layoutCache = *renderContext.LayoutCache;
		Layout = GetDescriptorSetLayout(renderContext);
		for (uint32_t i = 0; i < (uint32_t)MaterialSets.size(); ++i)
		{
			descAllocator.Allocate(&MaterialSets[i].TextureSet, Layout);
			MaterialSets[i].ParamsSet = VK_NULL_HANDLE;
		}
	}

	void MaterialRenderData::Destroy(const RenderContext& renderContext)
	{	}


	EnvironmentData::EnvironmentData() :
		AmbientColor(0.02f, 0.02f, 0.02f),
		ActiveSpotLightsCount(0.f),
		ViewPosition(0.f),
		ActiveLightsCount(0.f)
	{
		DirectionalLight.Color = { 0.01f, 0.01f, 0.1f };
		DirectionalLight.Position = { 0.f, 0.f, 1.f };
		DirectionalLight.ShadowMapIndex = -1.f;
		DirectionalLight.Compression = 0.5f;
		for (uint32_t i = 0; i < MaxLights; ++i)
		{
			Lights[i] = DirectionalLight;
			Lights[i].Radius = 50.f;
			SpotLights[i].Direction = { 1.f, 0.f, 0.f };
			SpotLights[i].Position = { 0.f, 0.f, 0.f };
			SpotLights[i].Color = { 1.f, 1.f, 1.f };
			SpotLights[i].InnerCutoff = 1.f;
			SpotLights[i].OuterCutoff = 0.5f;
			SpotLights[i].ShadowMapIndex = -1.f;
		}
		//memset(this, 0, sizeof(*this));
		ZeroMemory(this, sizeof(*this));
		AmbientColor = { 0.02f, 0.02f, 0.02f };
	}


	IScene* IScene::CreateScene(IRenderEngine* engine)
	{
		check(!engine->GetScene());
		Scene* scene = new Scene(engine);
		engine->SetScene(scene);
		scene->Init();
		return scene;
	}

	IScene* IScene::LoadScene(IRenderEngine* engine, const char* sceneFilepath)
	{
		Scene* scene = static_cast<Scene*>(CreateScene(engine));
		scene->LoadScene(sceneFilepath);
		return scene;
	}

	void IScene::DestroyScene(IScene* scene)
	{
		scene->Destroy();
		delete scene;
	}

	Scene::Scene(IRenderEngine* engine) : IScene(), m_engine(static_cast<VulkanRenderEngine*>(engine))
	{
		// Create root scene
		//CreateRenderObject(RenderObject::InvalidId);
	}

	Scene::~Scene()
	{}

	void Scene::Init()
	{
		// default material
		Material* mat = CreateMaterial();
		mat->SetName("DefaultMaterial");
	}

	void Scene::Destroy()
	{
		if (m_engine->GetScene() == this)
			m_engine->SetScene(nullptr);
		m_localTransforms.clear();
		m_globalTransforms.clear();
		m_hierarchy.clear();
		m_meshArray.clear();
		m_names.clear();
		for (uint32_t i = 0; i < MaxNodeLevel; ++i)
			m_dirtyNodes[i].clear();

		const RenderContext& renderContext = m_engine->GetContext();
		for (auto& it : m_renderData.Meshes)
		{
			it.second.VertexBuffer.Destroy(renderContext);
			it.second.IndexBuffer.Destroy(renderContext);
		}
		for (uint32_t i = 0; i < (uint32_t)m_materialRenderDataArray.size(); ++i)
		{
			m_materialRenderDataArray[i].Destroy(m_engine->GetContext());
		}
		m_materialRenderDataArray.clear();
		m_materialArray.clear();
		for (auto& it : m_renderData.Textures)
		{
			Texture::Destroy(m_engine->GetContext(), it.second);
		}
	}

	void Scene::InitFrameData(const RenderContext& renderContext, RenderFrameContext& frameContext)
	{
		frameContext.GlobalBuffer.AllocDynamicUniform(renderContext, "Material", sizeof(MaterialUniform), MIST_MAX_MATERIALS);
	}

	RenderObject Scene::CreateRenderObject(RenderObject parent)
	{
		// Generate new node in all basics structures
		RenderObject node = (uint32_t)m_hierarchy.size();
		m_transformComponents.push_back({ .Position = glm::vec3(0.f), .Rotation = glm::vec3(0.f), .Scale = glm::vec3(1.f) });
		m_localTransforms.push_back(glm::mat4(1.f));
		m_globalTransforms.push_back(glm::mat4(1.f));
		char buff[64];
		sprintf_s(buff, "RenderObject_%u", node.Id);
		m_names.push_back(buff);
		m_hierarchy.push_back({ .Parent = parent });

		// Connect siblings
		if (parent.IsValid())
		{
			check(parent.Id < (uint32_t)m_hierarchy.size());
			RenderObject firstSibling = m_hierarchy[parent].Child;
			if (firstSibling.IsValid())
			{
				RenderObject sibling;
				for (sibling = firstSibling; m_hierarchy[sibling].Sibling.IsValid(); sibling = m_hierarchy[sibling].Sibling);
				m_hierarchy[sibling].Sibling = node;
			}
			else
			{
				m_hierarchy[parent].Child = node;
			}
		}

		m_hierarchy[node].Level = parent.IsValid() ? m_hierarchy[parent].Level + 1 : 0;
		m_hierarchy[node].Child = RenderObject::InvalidId;
		m_hierarchy[node].Sibling = RenderObject::InvalidId;
		return node;
	}

	bool Scene::LoadModel(const char* filepath)
	{
		cgltf_data* data = gltf_api::ParseFile(filepath);
		char rootAssetPath[512];
		io::GetDirectoryFromFilepath(filepath, rootAssetPath, 512);
		if (!data)
		{
			Logf(LogLevel::Error, "Cannot open file to load scene model: %s.\n", filepath);
			return false;
		}

		std::unordered_map<cgltf_material*, uint32_t> materialIndexMap;
		materialIndexMap[nullptr] = m_defaultMaterialIndex;
		for (uint32_t i = 0; i < data->materials_count; ++i)
		{
			Material* m = CreateMaterial();
			gltf_api::LoadMaterial(m_engine->GetContext(), *this, rootAssetPath, *m, data->materials[i]);
			materialIndexMap[&data->materials[i]] = m->GetHandle();
			UpdateMaterialBindings(*m);
		}

		uint32_t nodesCount = (uint32_t)data->nodes_count;
		uint32_t renderObjectOffset = GetRenderObjectCount();
		for (uint32_t i = 0; i < nodesCount; ++i)
		{
			const cgltf_node& node = data->nodes[i];
			RenderObject parent = GetRoot();
			if (node.parent)
			{
				for (uint32_t j = 0; j < i; ++j)
				{
					if (&data->nodes[j] == node.parent)
					{
						parent = j + renderObjectOffset;
						break;
					}
				}
			}
			RenderObject renderObject = CreateRenderObject(parent);

			// Process transform
			glm::mat4 localTransform(1.f);
			gltf_api::ReadNodeLocalTransform(node, localTransform);
			TransformComponent t;
			math::DecomposeMatrix(localTransform, t.Position, t.Rotation, t.Scale);
			SetTransform(renderObject, t);

			// Process mesh
			if (node.mesh)
			{
				Mesh mesh;
				tDynArray<PrimitiveMeshData> primitives;
				gltf_api::LoadGeometry(mesh, primitives, materialIndexMap, node, *data);

				// Submit data
				// Create mesh component associated
				MeshComponent mc;
				strcpy_s(mc.MeshAssetPath, filepath);
				mc.MeshName = node.mesh->name;
				mc.MeshIndex = SubmitMesh(mesh);

				// TODO: find out a better way to assign primitives to mesh render data.
				MeshRenderData& mrd = GetMeshRenderData(mesh.GetHandle());
				mrd.PrimitiveArray = std::move(primitives);
				mrd.IndexCount = (uint32_t)mesh.GetIndexCount();

				SetMesh(renderObject, mc);

				if (node.mesh->name && *node.mesh->name)
					SetRenderObjectName(renderObject, node.mesh->name);
			}
		}
		gltf_api::FreeData(data);
		return true;
	}

	void Scene::LoadScene(const char* filepath)
	{
		io::File file;
		check(file.Open(filepath, "r"));
		uint32_t size = file.GetContentSize();
		char* content = new char[size];
		uint32_t contentReaded = file.Read(content, size, sizeof(char), size);
		file.Close();
		check(contentReaded <= size);
		content[contentReaded == size ? size - 1 : contentReaded] = 0;

		YAML::Node root = YAML::Load(content);
		check(root);
		YAML::Node envNode = root["Environment"];
		check(envNode);
		m_ambientColor = envNode["Ambient"].as<glm::vec3>();
		char skyboxTextures[Skybox::COUNT][256];
		strcpy_s(skyboxTextures[Skybox::FRONT], envNode["Skybox"]["Front"].as<tString>().c_str());
		strcpy_s(skyboxTextures[Skybox::BACK], envNode["Skybox"]["Back"].as<tString>().c_str());
		strcpy_s(skyboxTextures[Skybox::TOP], envNode["Skybox"]["Top"].as<tString>().c_str());
		strcpy_s(skyboxTextures[Skybox::BOTTOM], envNode["Skybox"]["Bottom"].as<tString>().c_str());
		strcpy_s(skyboxTextures[Skybox::LEFT], envNode["Skybox"]["Left"].as<tString>().c_str());
		strcpy_s(skyboxTextures[Skybox::RIGHT], envNode["Skybox"]["Right"].as<tString>().c_str());
		LoadSkybox(m_engine->GetContext(), m_skybox,
			skyboxTextures[Skybox::FRONT],
			skyboxTextures[Skybox::BACK],
			skyboxTextures[Skybox::LEFT],
			skyboxTextures[Skybox::RIGHT],
			skyboxTextures[Skybox::TOP],
			skyboxTextures[Skybox::BOTTOM]);



		YAML::Node renderObjectSeq = root["RenderObjects"];
		check(renderObjectSeq);
		for (const auto& it : renderObjectSeq)
		{
			uint32_t parent = it["Parent"].as<uint32_t>();
			RenderObject rb = CreateRenderObject(parent);
			SetRenderObjectName(rb, it["Name"].as<tString>().c_str());

			TransformComponent t;
			YAML::Node transformNode = it["TransformComponent"];
			t.Position = transformNode["Position"].as<glm::vec3>();
			t.Rotation = transformNode["Rotation"].as<glm::vec3>();
			t.Scale = transformNode["Scale"].as<glm::vec3>();
			SetTransform(rb, t);

			YAML::Node lightNode = it["LightComponent"];
			if (lightNode)
			{
				LightComponent lightComponent;
				lightComponent.Color = lightNode["Color"].as<glm::vec3>();
				lightComponent.Radius = lightNode["Radius"].as<float>();
				lightComponent.Compression = lightNode["Compression"].as<float>();
				lightComponent.InnerCutoff = lightNode["InnerCutoff"].as<float>();
				lightComponent.OuterCutoff = lightNode["OuterCutoff"].as<float>();
				lightComponent.ProjectShadows = lightNode["ProjectShadows"].as<bool>();
				lightComponent.Type = StrToLightType(lightNode["Type"].as<tString>().c_str());
				SetLight(rb, lightComponent);
			}

			YAML::Node meshNode = it["MeshComponent"];
			if (meshNode)
			{
				MeshComponent m;
				strcpy_s(m.MeshAssetPath, meshNode["MeshAssetPath"].as<tString>().c_str());
				m.MeshName = meshNode["MeshName"].as<tString>();
				m.MeshIndex = UINT32_MAX;
				if (!m_meshNameIndexMap.contains(m.MeshAssetPath))
					check(LoadMeshesFromFile(m.MeshAssetPath));
				const tDynArray<uint32_t>& sceneMeshes = m_meshNameIndexMap[m.MeshAssetPath];
				for (uint32_t i = 0; i < (uint32_t)sceneMeshes.size(); ++i)
				{
					if (!strcmp(m.MeshName.c_str(), m_meshArray[sceneMeshes[i]].GetName()))
					{
						m.MeshIndex = sceneMeshes[i];
						break;
					}
				}
				check(m.MeshIndex != UINT32_MAX);
				SetMesh(rb, m);
			}
		}
		delete[] content;
	}

	void Scene::SaveScene(const char* filepath)
	{
		YAML::Emitter emitter;

		emitter << YAML::BeginMap;
		emitter << YAML::Key << "Environment";
		{
			emitter << YAML::BeginMap;
			emitter << YAML::Key << "Ambient" << YAML::Value << m_ambientColor;
			emitter << YAML::Key << "Skybox" << YAML::BeginMap;
			emitter << YAML::Key << "Front" << YAML::Value << m_skybox.CubemapFiles[Skybox::FRONT];
			emitter << YAML::Key << "Back" << YAML::Value << m_skybox.CubemapFiles[Skybox::BACK];
			emitter << YAML::Key << "Top" << YAML::Value << m_skybox.CubemapFiles[Skybox::TOP];
			emitter << YAML::Key << "Bottom" << YAML::Value << m_skybox.CubemapFiles[Skybox::BOTTOM];
			emitter << YAML::Key << "Left" << YAML::Value << m_skybox.CubemapFiles[Skybox::LEFT];
			emitter << YAML::Key << "Right" << YAML::Value << m_skybox.CubemapFiles[Skybox::RIGHT];
			emitter << YAML::EndMap;
			emitter << YAML::EndMap;
		}
		emitter << YAML::Key << "RenderObjects";
		emitter << YAML::BeginSeq;
		for (uint32_t i = 0; i < GetRenderObjectCount(); ++i)
		{
			const Hierarchy& h = m_hierarchy[i];
			emitter << YAML::BeginMap;
			emitter << YAML::Key << "RenderObject" << YAML::Value << i;
			emitter << YAML::Key << "Name" << YAML::Value << GetRenderObjectName(i);
			emitter << YAML::Key << "Parent" << YAML::Value << h.Parent;

			const TransformComponent& t = m_transformComponents[i];
			emitter << YAML::Key << "TransformComponent" << YAML::BeginMap;
			emitter << YAML::Key << "Position" << YAML::Value << t.Position;
			emitter << YAML::Key << "Rotation" << YAML::Value << t.Rotation;
			emitter << YAML::Key << "Scale" << YAML::Value << t.Scale;
			emitter << YAML::EndMap;

			if (m_lightComponentMap.contains(i))
			{
				const LightComponent& light = m_lightComponentMap[i];
				emitter << YAML::Key << "LightComponent" << YAML::BeginMap;
				emitter << YAML::Key << "Type" << YAML::Value << LightTypeToStr(light.Type);
				emitter << YAML::Key << "Color" << YAML::Value << light.Color;
				emitter << YAML::Key << "Radius" << YAML::Value << light.Radius;
				emitter << YAML::Key << "Compression" << YAML::Value << light.Radius;
				emitter << YAML::Key << "InnerCutoff" << YAML::Value << light.InnerCutoff;
				emitter << YAML::Key << "OuterCutoff" << YAML::Value << light.OuterCutoff;
				emitter << YAML::Key << "ProjectShadows" << YAML::Value << light.ProjectShadows;
				emitter << YAML::EndMap;
			}

			if (m_meshComponentMap.contains(i))
			{
				emitter << YAML::Key << "MeshComponent" << YAML::BeginMap;
				const MeshComponent& mesh = m_meshComponentMap[i];
				emitter << YAML::Key << "MeshAssetPath" << YAML::Value << mesh.MeshAssetPath;
				emitter << YAML::Key << "MeshName" << YAML::Value << mesh.MeshName;
				emitter << YAML::EndMap;
			}

			emitter << YAML::EndMap;
		}
		emitter << YAML::EndSeq;
		emitter << YAML::EndMap;

		check(emitter.good());
		const char* out = emitter.c_str();
		uint32_t size = (uint32_t)emitter.size();
		Logf(LogLevel::Info, "YAML %u b\n%s\n", size, out);

		io::File file;
		check(file.Open(filepath, "w"));
		file.Write(out, size);
		file.Close();
	}

	void Scene::DestroyRenderObject(RenderObject object)
	{
		check(false && "not implemented yet" && __FUNCTION__ && __FILE__ && __LINE__);
	}

	const MeshComponent* Scene::GetMesh(RenderObject renderObject) const
	{
		check(IsValid(renderObject));
		const MeshComponent* mesh = nullptr;
		if (m_meshComponentMap.contains(renderObject))
			mesh = &m_meshComponentMap.at(renderObject);
		return mesh;
	}

	void Scene::SetMesh(RenderObject renderObject, const MeshComponent& meshComponent)
	{
		check(IsValid(renderObject));
		check(meshComponent.MeshIndex < (uint32_t)m_meshArray.size());
		m_meshComponentMap[renderObject] = meshComponent;
	}

	const char* Scene::GetRenderObjectName(RenderObject object) const
	{
		return IsValid(object) ? m_names[object.Id].c_str() : nullptr;
	}

	bool Scene::IsValid(RenderObject object) const
	{
		return object.Id < (uint32_t)m_hierarchy.size();
	}

	uint32_t Scene::GetRenderObjectCount() const
	{
		return (uint32_t)m_hierarchy.size();
	}

	Material* Scene::CreateMaterial()
	{
		check(m_materialArray.size() == m_materialRenderDataArray.size());
		check(m_materialArray.size() < MIST_MAX_MATERIALS);
		uint32_t matIndex = (uint32_t)m_materialArray.size();
		m_materialArray.push_back(Material());
		m_materialRenderDataArray.push_back(MaterialRenderData());
		Material& mat = m_materialArray[matIndex];
		MaterialRenderData& renderData = m_materialRenderDataArray[matIndex];
		renderData.Init(m_engine->GetContext());
		mat.SetHandle(matIndex);
		return &mat;
	}

	Material* Scene::GetMaterial(uint32_t index)
	{
		check(index < (uint32_t)m_materialArray.size());
		return &m_materialArray[index];
	}

	const Material* Scene::GetMaterial(uint32_t index) const
	{
		check(index < (uint32_t)m_materialArray.size());
		return &m_materialArray[index];
	}

	RenderObject Scene::GetRoot() const
	{
		static RenderObject root = 0;
		//for (; m_hierarchy[root].Parent.IsValid(); root = m_hierarchy[root].Parent);
		return root;
	}

	void Scene::SetRenderObjectName(RenderObject renderObject, const char* name)
	{
		check(IsValid(renderObject));
		m_names[renderObject] = name;
	}

	const TransformComponent& Scene::GetTransform(RenderObject renderObject) const
	{
		check(IsValid(renderObject));
		return m_transformComponents[renderObject];
	}

	void Scene::SetTransform(RenderObject renderObject, const TransformComponent& transform)
	{
		check(IsValid(renderObject));
		m_transformComponents[renderObject] = transform;
		MarkAsDirty(renderObject);
	}

	const LightComponent* Scene::GetLight(RenderObject renderObject) const
	{
		check(IsValid(renderObject));
		const LightComponent* light = nullptr;
		if (m_lightComponentMap.contains(renderObject))
			light = &m_lightComponentMap.at(renderObject);
		return light;
	}

	void Scene::SetLight(RenderObject renderObject, const LightComponent& light)
	{
		check(IsValid(renderObject));
		m_lightComponentMap[renderObject] = light;
	}

	uint32_t Scene::SubmitMesh(Mesh& mesh)
	{
		check(!mesh.GetHandle().IsValid());
		check(mesh.GetVertexCount() > 0 && mesh.GetIndexCount() > 0);
		// Prepare buffer creation
		const uint32_t vertexBufferSize = (uint32_t)mesh.GetVertexCount() * sizeof(Vertex);

		MeshRenderData mrd{};
		// Create vertex buffer
		mrd.VertexBuffer.Init(m_engine->GetContext(), { .Size = vertexBufferSize });
		GPUBuffer::SubmitBufferToGpu(mrd.VertexBuffer, mesh.GetVertices(), vertexBufferSize);

		uint32_t indexBufferSize = (uint32_t)(mesh.GetIndexCount() * sizeof(uint32_t));
		mrd.IndexBuffer.Init(m_engine->GetContext(), { .Size = indexBufferSize });
		GPUBuffer::SubmitBufferToGpu(mrd.IndexBuffer, mesh.GetIndices(), indexBufferSize);

		// Register new buffer
		RenderHandle handle = GenerateRenderHandle();
		mesh.SetHandle(handle);
		m_renderData.Meshes[handle] = mrd;

		uint32_t meshIndex = (uint32_t)m_meshArray.size();
		m_meshArray.push_back(mesh);
		return meshIndex;
	}

	uint32_t Scene::SubmitMaterial(Material& material)
	{
		UpdateMaterialBindings(material);
		return material.GetHandle();
	}

	RenderHandle Scene::SubmitTexture(Texture* tex)
	{
		RenderHandle h = GenerateRenderHandle();
		m_renderData.Textures[h] = tex;
		return h;
	}

	void Scene::UpdateMaterialBindings(Material& material)
	{
		check(material.GetHandle() < (uint32_t)m_materialArray.size());
		if (material.IsDirty())
		{
			m_dirtyMaterials.push_back(material.GetHandle());
		}
	}

	RenderHandle Scene::LoadTexture(const char* texturePath) { check(false); return RenderHandle(); }
	RenderHandle Scene::LoadTexture(const RenderContext& context, const char* texturePath, EFormat format)
	{
		Texture* tex;
		check(LoadTextureFromFile(context, texturePath, &tex, format));
		return SubmitTexture(tex);
	}

	void Scene::MarkAsDirty(RenderObject renderObject)
	{
		check(IsValid(renderObject));
		int32_t level = m_hierarchy[renderObject].Level;
		m_dirtyNodes[level].push_back(renderObject);
		for (RenderObject child = m_hierarchy[renderObject].Child; child.IsValid(); child = m_hierarchy[child].Sibling)
			MarkAsDirty(child);
	}


	void Scene::RecalculateTransforms()
	{
		check(m_localTransforms.size() == m_transformComponents.size());
		check(m_globalTransforms.size() == m_transformComponents.size());
		TransformComponentToMatrix(m_transformComponents.data(), m_localTransforms.data(), (uint32_t)m_transformComponents.size());
		// Process root level first
		if (!m_dirtyNodes[0].empty())
		{
			for (uint32_t i = 0; i < m_dirtyNodes[0].size(); ++i)
			{
				uint32_t nodeIndex = m_dirtyNodes[0][i];
				m_globalTransforms[nodeIndex] = m_localTransforms[nodeIndex];
			}
			m_dirtyNodes[0].clear();
		}
		// Iterate over the deeper levels
		for (uint32_t level = 1; level < MaxNodeLevel; ++level)
		{
			for (uint32_t nodeIndex = 0; nodeIndex < m_dirtyNodes[level].size(); ++nodeIndex)
			{
				int32_t node = m_dirtyNodes[level][nodeIndex];
				int32_t parentNode = m_hierarchy[node].Parent;
				m_globalTransforms[node] = m_globalTransforms[parentNode] * m_localTransforms[node];
			}
			m_dirtyNodes[level].clear();
		}
	}

	bool Scene::LoadMeshesFromFile(const char* filepath)
	{
		check(!m_meshNameIndexMap.contains(filepath));
		cgltf_data* data = gltf_api::ParseFile(filepath);
		char rootAssetPath[512];
		io::GetDirectoryFromFilepath(filepath, rootAssetPath, 512);
		if (!data)
		{
			Logf(LogLevel::Error, "Cannot open file to load scene model: %s.\n", filepath);
			return false;
		}

		std::unordered_map<cgltf_material*, uint32_t> materialIndexMap;
		materialIndexMap[nullptr] = m_defaultMaterialIndex;
		for (uint32_t i = 0; i < data->materials_count; ++i)
		{
			Material* m = CreateMaterial();
			gltf_api::LoadMaterial(m_engine->GetContext(), *this, rootAssetPath, *m, data->materials[i]);
			materialIndexMap[&data->materials[i]] = m->GetHandle();
			UpdateMaterialBindings(*m);
		}

		uint32_t nodesCount = (uint32_t)data->nodes_count;
		uint32_t renderObjectOffset = GetRenderObjectCount();
		for (uint32_t i = 0; i < nodesCount; ++i)
		{
			const cgltf_node& node = data->nodes[i];

			// Process mesh
			if (node.mesh)
			{
				Mesh mesh;
				tDynArray<PrimitiveMeshData> primitives;
				gltf_api::LoadGeometry(mesh, primitives, materialIndexMap, node, *data);
				uint32_t meshIndex = SubmitMesh(mesh);
				m_meshNameIndexMap[filepath].push_back(meshIndex);
				MeshRenderData& mrd = GetMeshRenderData(m_meshArray[meshIndex].GetHandle());
				mrd.PrimitiveArray = std::move(primitives);
				mrd.IndexCount = mesh.GetIndexCount();
			}
		}
		gltf_api::FreeData(data);
		return true;
	}

	bool Scene::LoadSkybox(const RenderContext& context, Skybox& skybox, const char* front, const char* back, const char* left, const char* right, const char* top, const char* bottom)
	{
		// descriptors generator
		DescriptorBuilder builder = DescriptorBuilder::Create(*context.LayoutCache, *context.DescAllocator);

		// Load textures from files
		const char* files[] = { left, right, top, bottom, front, back };
		io::TextureRaw textureData[Skybox::COUNT];
		for (uint32_t i = 0; i < Skybox::COUNT; ++i)
			check(io::LoadTexture(files[i], textureData[i]));
		// Size integrity check and generate an array to reference the pixels of each texture.
		const uint8_t* pixelsArray[Skybox::COUNT];
		for (uint32_t i = 0; i < Skybox::COUNT; ++i)
		{
			check(*files[i]);
			strcpy_s(skybox.CubemapFiles[i], files[i]);
			check(textureData[i].Width == textureData[(i + 1) % Skybox::COUNT].Width
				&& textureData[i].Height == textureData[(i + 1) % Skybox::COUNT].Height
				&& textureData[i].Channels == textureData[(i + 1) % Skybox::COUNT].Channels
				&& textureData[i].Pixels);
			pixelsArray[i] = textureData[i].Pixels;
		}

		// Create texture
		tImageDescription imageDesc;
		imageDesc.Format = FORMAT_R8G8B8A8_SRGB;
		imageDesc.Layers = Skybox::COUNT;
		imageDesc.Width = textureData[0].Width;
		imageDesc.Height = textureData[0].Height;
		imageDesc.Depth = 1;
		imageDesc.Flags = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT;
		imageDesc.MipLevels = 1; // needs cubemap?
		imageDesc.SampleCount = SAMPLE_COUNT_1_BIT;
		Texture* cubemapTex = Texture::Create(context, imageDesc);
		// Set image layers with each cubemap texture
		cubemapTex->SetImageLayers(context, pixelsArray, Skybox::COUNT);
		SubmitTexture(cubemapTex);

		tViewDescription viewDesc;
		viewDesc.BaseArrayLayer = 0;
		viewDesc.LayerCount = Skybox::COUNT;
		viewDesc.ViewType = VK_IMAGE_VIEW_TYPE_CUBE;
		VkDescriptorImageInfo info;
		info.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
		info.imageView = cubemapTex->CreateView(context, viewDesc);
		info.sampler = cubemapTex->GetSampler();
		builder.BindImage(0, &info, 1, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_SHADER_STAGE_FRAGMENT_BIT);
		check(builder.Build(context, skybox.CubemapSet));

		// Mesh
		static const char* cubeMeshFile = ASSET_PATH("models/cube.gltf");
		if (!m_meshNameIndexMap.contains(cubeMeshFile))
			LoadMeshesFromFile(cubeMeshFile);
		check(m_meshNameIndexMap.contains(cubeMeshFile) && m_meshNameIndexMap[cubeMeshFile].size() == 1);
		skybox.MeshIndex = m_meshNameIndexMap[cubeMeshFile][0];

		return true;
	}

	const Mesh* Scene::GetMeshArray() const
	{
		return m_meshArray.data();
	}

	uint32_t Scene::GetMeshCount() const
	{
		return (uint32_t)m_meshArray.size();
	}

	const Material* Scene::GetMaterialArray() const
	{
		return m_materialArray.data();
	}

	uint32_t Scene::GetMaterialCount() const
	{
		return (uint32_t)m_materialArray.size();
	}

	const MeshRenderData& Scene::GetMeshRenderData(RenderHandle handle) const
	{
		return m_renderData.Meshes.at(handle);
	}

	MeshRenderData& Scene::GetMeshRenderData(RenderHandle handle)
	{
		return m_renderData.Meshes.at(handle);
	}

	const MaterialRenderData& Scene::GetMaterialRenderData(RenderHandle handle) const
	{
		check(handle < (uint32_t)m_materialRenderDataArray.size());
		return m_materialRenderDataArray.at(handle);
	}

	MaterialRenderData& Scene::GetMaterialRenderData(RenderHandle handle)
	{
		check(handle < (uint32_t)m_materialRenderDataArray.size());
		return m_materialRenderDataArray.at(handle);
	}

	void Scene::Draw(VkCommandBuffer cmd, ShaderProgram* shader, uint32_t materialSetIndex, uint32_t modelSetIndex, VkDescriptorSet modelSet) const
	{
		CPU_PROFILE_SCOPE(Scene_Draw);
		// Iterate scene graph to render models.
		uint32_t lastMaterialIndex = UINT32_MAX;
		const Mesh* lastMesh = nullptr;
		uint32_t nodeCount = GetRenderObjectCount();
		for (uint32_t i = 0; i < nodeCount; ++i)
		{
			RenderObject renderObject = i;
			const MeshComponent* meshComponent = GetMesh(renderObject);
			if (meshComponent)
			{
				check(meshComponent->MeshIndex < (uint32_t)m_meshArray.size());
				const Mesh* mesh = &m_meshArray[meshComponent->MeshIndex];
				const MeshRenderData& mrd = GetMeshRenderData(mesh->GetHandle());

				// BaseOffset in buffer is already setted when descriptor was created.
				uint32_t modelDynamicOffset = i * sizeof(glm::mat4);
				shader->BindDescriptorSets(cmd, &modelSet, 1, modelSetIndex, &modelDynamicOffset, 1);
				++Mist::Profiling::GRenderStats.SetBindingCount;

				// Bind vertex/index buffers just if needed
				if (lastMesh != mesh)
				{
					check(mesh->GetHandle().IsValid());
					lastMesh = mesh;
					mrd.BindBuffers(cmd);
				}
				// Iterate primitives of current mesh
				for (uint32_t j = 0; j < (uint32_t)mrd.PrimitiveArray.size(); ++j)
				{
					const PrimitiveMeshData& drawData = mrd.PrimitiveArray[j];
					// TODO: material by default if there is no material.
					if (lastMaterialIndex != drawData.MaterialIndex)
					{
						lastMaterialIndex = drawData.MaterialIndex;
						uint32_t materialPadding = Memory::PadOffsetAlignment((uint32_t)m_engine->GetContext().GPUProperties.limits.minUniformBufferOffsetAlignment, sizeof(MaterialUniform));
						uint32_t bufferOffset = materialPadding * drawData.MaterialIndex;
						const MaterialRenderData& mtl = m_materialRenderDataArray[lastMaterialIndex];
						shader->BindDescriptorSets(cmd, &mtl.MaterialSets[m_engine->GetFrameIndex()].TextureSet, 1, materialSetIndex);
						shader->BindDescriptorSets(cmd, &mtl.MaterialSets[m_engine->GetFrameIndex()].ParamsSet, 1, materialSetIndex + 1, &bufferOffset, 1);
					}
					RenderAPI::CmdDrawIndexed(cmd, drawData.Count, 1, drawData.FirstIndex, 0, 0);
				}
			}
		}
	}

	void Scene::Draw(VkCommandBuffer cmd, ShaderProgram* shader, uint32_t modelSetIndex, VkDescriptorSet modelSet) const
	{
		CPU_PROFILE_SCOPE(Scene_Draw);
		// Iterate scene graph to render models.
		uint32_t lastMaterialIndex = UINT32_MAX;
		const Mesh* lastMesh = nullptr;
		uint32_t nodeCount = GetRenderObjectCount();
		for (uint32_t i = 0; i < nodeCount; ++i)
		{
			RenderObject renderObject = i;
			const MeshComponent* meshComponent = GetMesh(renderObject);
			if (meshComponent)
			{
				check(meshComponent->MeshIndex < (uint32_t)m_meshArray.size());
				const Mesh* mesh = &m_meshArray[meshComponent->MeshIndex];
				const MeshRenderData& mrd = GetMeshRenderData(mesh->GetHandle());

				// BaseOffset in buffer is already setted when descriptor was created.
				uint32_t modelDynamicOffset = i * sizeof(glm::mat4);
				shader->BindDescriptorSets(cmd, &modelSet, 1, modelSetIndex, &modelDynamicOffset, 1);

				// Bind vertex/index buffers just if needed
				if (lastMesh != mesh)
				{
					check(mesh->GetHandle().IsValid());
					lastMesh = mesh;
					mrd.BindBuffers(cmd);
				}
				RenderAPI::CmdDrawIndexed(cmd, mrd.IndexCount, 1, 0, 0, 0);
#if 0
				for (uint32_t j = 0; j < (uint32_t)mrd.PrimitiveArray.size(); ++j)
				{
					const PrimitiveMeshData& drawData = mrd.PrimitiveArray[j];
					vkCmdDrawIndexed(cmd, drawData.Count, 1, drawData.FirstIndex, 0, 0);
					++GRenderStats.DrawCalls;
					GRenderStats.TrianglesCount += drawData.Count / 3;
				}
#endif // 0

			}
		}
	}

	void Scene::DrawSkybox(CommandBuffer cmd, ShaderProgram* shader)
	{
		if (m_skybox.CubemapSet != VK_NULL_HANDLE)
		{
			const Mesh& mesh = m_meshArray[m_skybox.MeshIndex];
			const MeshRenderData& mrd = m_renderData.Meshes[mesh.GetHandle()];
			mrd.BindBuffers(cmd);
			shader->BindDescriptorSets(cmd, &m_skybox.CubemapSet, 1, 1, nullptr, 0);
			RenderAPI::CmdDrawIndexed(cmd, mrd.IndexCount, 1, 0, 0, 0);
		}
	}

	void Scene::ImGuiDraw()
	{
		ImGui::Begin("SceneGraph");

		float posStep = 0.5f;
		float rotStep = 0.1f;
		float sclStep = 0.5f;

		static char sceneFile[256];
		static bool _b = false;
		if (!_b)
		{
			strcpy_s(sceneFile, "scenes/Scene.yaml");
			_b = !false;
		}
		ImGui::Columns(3);
		if (ImGui::Button("Save"))
			SaveScene(sceneFile);
		ImGui::NextColumn();
		if (ImGui::Button("Load"))
			LoadScene(sceneFile);
		ImGui::NextColumn();
		ImGui::InputText("Scene file", sceneFile, 256);
		ImGui::Columns();

		ImGui::Separator();
		ImGui::Text("Environment");
		ImGui::ColorEdit3("Ambient color", &m_ambientColor[0]);
		ImGui::Button("Reload");

		ImGui::Separator();
		if (ImGui::TreeNode("Scene tree"))
		{
			for (uint32_t i = 0; i < GetRenderObjectCount(); ++i)
			{
				char treeId[2];
				sprintf(treeId, "%u", i);
				if (ImGui::TreeNode(treeId, "%s", GetRenderObjectName(i)))
				{
					glm::mat4 transform;
					TransformComponentToMatrix(&m_transformComponents[i], &transform, 1);
					DebugRender::DrawAxis(transform);
					const Hierarchy& node = m_hierarchy[i];
					ImGui::Text("Parent: %s", node.Parent != RenderObject::InvalidId ? GetRenderObjectName(node.Parent) : "None");
					char buff[32];
					sprintf_s(buff, "##TransformComponent%u", i);
					if (ImGui::TreeNode(buff, "Transform component"))
					{
						TransformComponent& t = m_transformComponents[i];
						ImGui::Columns(2);
						ImGui::Text("Position");
						ImGui::NextColumn();
						sprintf_s(buff, "##TransformPos%d", i);
						bool dirty = ImGui::DragFloat3(buff, &t.Position[0], posStep);
						ImGui::NextColumn();
						ImGui::Text("Rotation");
						ImGui::NextColumn();
						sprintf_s(buff, "##TransformRot%d", i);
						dirty |= ImGui::DragFloat3(buff, &t.Rotation[0], rotStep);
						ImGui::NextColumn();
						ImGui::Text("Scale");
						ImGui::NextColumn();
						sprintf_s(buff, "##TransformScl%d", i);
						dirty |= ImGui::DragFloat3(buff, &t.Scale[0], sclStep);
						ImGui::Columns();
						ImGui::TreePop();

						if (dirty)
							MarkAsDirty(i);
					}
					sprintf_s(buff, "##LightComponent%u", i);
					if (m_lightComponentMap.contains(i))
					{
						if (ImGui::TreeNode(buff, "Light component"))
						{
							LightComponent& light = m_lightComponentMap[i];
							static const char* lightTypes[] = { "Point", "Directional", "Spot" };
							uint32_t lightCount = sizeof(lightTypes) / sizeof(const char*);
							if (ImGui::BeginCombo("Type", lightTypes[(uint32_t)light.Type]))
							{
								for (uint32_t j = 0; j < lightCount; ++j)
								{
									if (ImGui::Selectable(lightTypes[j], j == (uint32_t)light.Type))
										light.Type = (ELightType)j;
								}
								ImGui::EndCombo();
							}
							ImGui::Columns(2);
							ImGui::Text("Color");
							ImGui::NextColumn();
							sprintf_s(buff, "##LightColor%u", i);
							ImGui::ColorEdit3(buff, &light.Color[0]);
							ImGui::NextColumn();
							ImGui::Text("Radius");
							ImGui::NextColumn();
							sprintf_s(buff, "##LightRadius%u", i);
							ImGui::DragFloat(buff, &light.Radius, 0.5f, 0.f, FLT_MAX);
							ImGui::NextColumn();
							ImGui::Text("Compression");
							sprintf_s(buff, "##LightCompression%u", i);
							ImGui::NextColumn();
							ImGui::DragFloat(buff, &light.Compression, 0.05f, 0.f, FLT_MAX);
							ImGui::NextColumn();
							ImGui::Text("Inner cutoff");
							ImGui::NextColumn();
							sprintf_s(buff, "##LightInnerCutoff%u", i);
							ImGui::DragFloat(buff, &light.InnerCutoff, 0.1f, 0.f, FLT_MAX);
							ImGui::NextColumn();
							ImGui::Text("Outer cutoff");
							ImGui::NextColumn();
							sprintf_s(buff, "##LightOuterCutoff%u", i);
							ImGui::DragFloat(buff, &light.OuterCutoff, 0.1f, 0.f, FLT_MAX);
							ImGui::NextColumn();
							ImGui::Text("Project shadows");
							ImGui::NextColumn();
							sprintf_s(buff, "##LightShadows%u", i);
							ImGui::Checkbox(buff, &light.ProjectShadows);
							ImGui::NextColumn();

							ImGui::Columns();
							ImGui::TreePop();
						}
					}

					ImGui::TreePop();
				}
			}
			ImGui::TreePop();
		}
		if (ImGui::TreeNode("Material list"))
		{
			char buff[32];
			for (uint32_t i = 0; i < (uint32_t)m_materialArray.size(); ++i)
			{
				if (ImGui::TreeNode(&m_materialArray[i], "(Slot %d) %s", i, m_materialArray[i].GetName()))
				{
					bool dirty = false;
					sprintf_s(buff, "##Metallic_%d", i);
					float metallic = m_materialArray[i].GetMetallic();
					dirty |= ImGui::DragFloat(buff, &metallic, 0.01f, 0.f, 1.f);
					sprintf_s(buff, "##Roughness_%d", i);
					float roughness = m_materialArray[i].GetMetallic();
					dirty |= ImGui::DragFloat(buff, &roughness, 0.01f, 0.f, 1.f);
					if (dirty)
					{
						m_materialArray[i].SetMetallic(metallic);
						m_materialArray[i].SetRoughness(roughness);
					}
					ImGui::TreePop();
				}
			}
			ImGui::TreePop();
		}
		ImGui::End();
	}

	bool Scene::IsDirty() const
	{
		for (uint32_t i = 0; i < MaxNodeLevel; ++i)
		{
			if (!m_dirtyNodes[i].empty())
				return true;
		}
		return false;
	}

	void Scene::UpdateRenderData(const RenderContext& renderContext, RenderFrameContext& frameContext)
	{
		if (GetRenderObjectCount())
		{
			// Update geometry
			RecalculateTransforms();
			check(!IsDirty());
			const glm::mat4& viewMat = frameContext.CameraData->InvView;
			EnvironmentData renderData;
			ProcessEnvironmentData(viewMat, renderData);

			UniformBufferMemoryPool* buffer = &frameContext.GlobalBuffer;
			check(buffer->SetUniform(renderContext, UNIFORM_ID_SCENE_ENV_DATA, &renderData, sizeof(EnvironmentData)));
			//check(buffer->SetUniform(renderContext, UNIFORM_ID_SCENE_MODEL_TRANSFORM_ARRAY, GetRawGlobalTransforms(), GetRenderObjectCount() * sizeof(glm::mat4)));
			check(buffer->SetDynamicUniform(renderContext, UNIFORM_ID_SCENE_MODEL_TRANSFORM_ARRAY, GetRawGlobalTransforms(), GetRenderObjectCount(), sizeof(glm::mat4), 0));

			// Update materials
			for (uint32_t i = 0; i < (uint32_t)m_materialArray.size(); ++i)
			{
				//check(m_dirtyMaterials[i] < (uint32_t)m_materialArray.size());
				Material& material = m_materialArray[i];
				//if (material.IsDirty())
				{
					RenderHandle h = material.GetHandle();
					MaterialRenderData& mrd = m_materialRenderDataArray[h];
					if (material.IsDirty())
					{
						auto submitTexture = [&](RenderHandle texHandle, uint32_t binding, uint32_t arrayIndex)
							{
								Texture* texture;
								if (texHandle.IsValid())
								{
									texture = m_renderData.Textures[texHandle];
								}
								else
								{
									RenderHandle defTex = m_engine->GetDefaultTexture();
									texture = m_renderData.Textures[defTex];
								}
								BindDescriptorTexture(m_engine->GetContext(), texture, mrd.MaterialSets[frameContext.FrameIndex].TextureSet, binding, arrayIndex);
							};
						submitTexture(material.GetAlbedoTexture(), 0, 0);
						submitTexture(material.GetNormalTexture(), 0, 1);
						submitTexture(material.GetSpecularTexture(), 0, 2);
						submitTexture(material.GetOcclusionTexture(), 0, 3);
						submitTexture(material.GetMetallicTexture(), 0, 4);
						submitTexture(material.GetRoughnessTexture(), 0, 5);
					}

					MaterialUniform ubo;
					ubo.Metallic = material.GetMetallic();
					ubo.Roughness = material.GetRoughness();
					buffer->SetDynamicUniform(renderContext, "Material", &ubo, 1, sizeof(MaterialUniform), h);

					if (mrd.MaterialSets[frameContext.FrameIndex].ParamsSet == VK_NULL_HANDLE)
					{
						VkDescriptorBufferInfo info = buffer->GenerateDescriptorBufferInfo("Material");
						DescriptorBuilder::Create(*renderContext.LayoutCache, *renderContext.DescAllocator)
							.BindBuffer(0, &info, 1, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_SHADER_STAGE_FRAGMENT_BIT)
							.Build(renderContext, mrd.MaterialSets[frameContext.FrameIndex].ParamsSet);
					}

					material.SetDirty(false);
				}
			}

			// Integrity check
			for (uint32_t i = 0; i < (uint32_t)m_materialArray.size(); ++i)
			{
				check(!m_materialArray[i].IsDirty());
			}
		}
	}

	const glm::mat4* Scene::GetRawGlobalTransforms() const
	{
		check(!IsDirty());
		return m_globalTransforms.data();
	}

	void Scene::ProcessEnvironmentData(const glm::mat4& viewSpace, EnvironmentData& environmentData)
	{
		environmentData.ViewPosition = math::GetPos(glm::inverse(viewSpace));
#if 1
		environmentData.AmbientColor = m_ambientColor;
		environmentData.ActiveLightsCount = 0.f;
		environmentData.ActiveSpotLightsCount = 0.f;
		uint32_t shadowMapIndex = 0;
		for (uint32_t i = 0; i < GetRenderObjectCount(); ++i)
		{
			if (m_lightComponentMap.contains(i))
			{
				const glm::mat4& mat = m_globalTransforms[i];
				const glm::vec3 pos = math::GetPos(viewSpace * mat);
				const glm::vec3 dir = math::GetDir(viewSpace * mat);
				const LightComponent& light = m_lightComponentMap[i];
				switch (light.Type)
				{
				case ELightType::Point:
					environmentData.Lights[(uint32_t)environmentData.ActiveLightsCount].Color = light.Color;
					environmentData.Lights[(uint32_t)environmentData.ActiveLightsCount].Compression = light.Compression;
					environmentData.Lights[(uint32_t)environmentData.ActiveLightsCount].Position = pos;
					environmentData.Lights[(uint32_t)environmentData.ActiveLightsCount].Radius = light.Radius;
					++environmentData.ActiveLightsCount;
					break;
				case ELightType::Directional:
					environmentData.DirectionalLight.Color = light.Color;
					environmentData.DirectionalLight.ShadowMapIndex = light.ProjectShadows ? (float)shadowMapIndex++ : -1.f;
					environmentData.DirectionalLight.Direction = dir;
					break;
				case ELightType::Spot:
					environmentData.SpotLights[(uint32_t)environmentData.ActiveSpotLightsCount].Color = light.Color;
					environmentData.SpotLights[(uint32_t)environmentData.ActiveSpotLightsCount].ShadowMapIndex = light.ProjectShadows ? (float)shadowMapIndex++ : -1.f;
					environmentData.SpotLights[(uint32_t)environmentData.ActiveSpotLightsCount].Position = pos;
					environmentData.SpotLights[(uint32_t)environmentData.ActiveSpotLightsCount].Direction = dir;
					environmentData.SpotLights[(uint32_t)environmentData.ActiveSpotLightsCount].InnerCutoff = light.InnerCutoff;
					environmentData.SpotLights[(uint32_t)environmentData.ActiveSpotLightsCount].OuterCutoff = light.OuterCutoff;
					++environmentData.ActiveSpotLightsCount;
					break;
				}
			}
		}
		check(shadowMapIndex <= globals::MaxShadowMapAttachments);
#endif // 0

	}

}
