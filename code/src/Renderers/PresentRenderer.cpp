// Autogenerated code for vkmmc project
// Source file
#include "PresentRenderer.h"
#include "Debug.h"
#include "Shader.h"
#include "Globals.h"
#include "InitVulkanTypes.h"
#include "Framebuffer.h"
#include "VulkanRenderEngine.h"

namespace vkmmc
{
    void PresentRenderer::Init(const RendererCreateInfo& info)
    {
		// Render pipeline
		m_descriptorSetLayout = info.InputAttachmentDescriptorSetLayout;
		VkDescriptorSetLayout setLayouts[] = { info.InputAttachmentDescriptorSetLayout };
		const uint32_t setLayoutCount = sizeof(setLayouts) / sizeof(VkDescriptorSetLayout);
		ShaderModuleLoadDescription shaderStageDescs[] =
		{
			{.ShaderFilePath = globals::PresentVertexShader, .Flags = VK_SHADER_STAGE_VERTEX_BIT},
			{.ShaderFilePath = globals::PresentFragmentShader, .Flags = VK_SHADER_STAGE_FRAGMENT_BIT}
		};

		VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo = vkinit::PipelineLayoutCreateInfo();
		pipelineLayoutCreateInfo.setLayoutCount = setLayoutCount;
		pipelineLayoutCreateInfo.pSetLayouts = setLayouts;
		pipelineLayoutCreateInfo.pushConstantRangeCount = info.ConstantRangeCount;
		pipelineLayoutCreateInfo.pPushConstantRanges = info.ConstantRange;
		m_pipeline = RenderPipeline::Create(
			info.RContext,
			info.RenderPass,
			1, // subpass
			shaderStageDescs,
			sizeof(shaderStageDescs) / sizeof(ShaderModuleLoadDescription),
			pipelineLayoutCreateInfo,
			VertexInputLayout::GetBasicVertexLayout()
		);

		// Create screen quad
		struct QuadVertex { glm::vec3 Position; glm::vec2 TexCoords; };
		std::vector<QuadVertex> vertices
		{
			{{-1.f, -1.f, 0.f}, {0.f, 0.f}},
			{{1.f, -1.f, 0.f}, {1.f, 0.f}},
			{{1.f, 1.f, 0.f}, {1.f, 1.f}},
			{{-1.f, 1.f, 0.f}, {0.f, 1.f}},
		};
		std::vector<uint32_t> indices{ 0, 2, 1, 0, 3, 2 };
		BufferCreateInfo createInfo;
		createInfo.RContext = info.RContext;
		createInfo.Size = (uint32_t)vertices.size() * sizeof(QuadVertex);
		createInfo.Data = vertices.data();
		m_quadVertexBuffer.Init(createInfo);
		createInfo.Size = (uint32_t)indices.size() * sizeof(uint32_t);
		createInfo.Data = indices.data();
		m_quadIndexBuffer.Init(createInfo);

		// Create descriptor to bind image render
		VulkanRenderEngine* engine = IRenderEngine::GetRenderEngineAs<VulkanRenderEngine>();
		m_descriptorSet = engine->AllocateDescriptorSet(m_descriptorSetLayout);
		// Create sampler
		VkSamplerCreateInfo samplerInfo = vkinit::SamplerCreateInfo(VK_FILTER_NEAREST, VK_SAMPLER_ADDRESS_MODE_REPEAT);
		vkcheck(vkCreateSampler(info.RContext.Device, &samplerInfo, nullptr, &m_sampler));
    }

    void PresentRenderer::Destroy(const RenderContext& renderContext)
    {
		vkDestroySampler(renderContext.Device, m_sampler, nullptr);
		m_quadIndexBuffer.Destroy(renderContext);
		m_quadVertexBuffer.Destroy(renderContext);

		m_pipeline.Destroy(renderContext);
		vkDestroyDescriptorSetLayout(renderContext.Device, m_descriptorSetLayout, nullptr);
    }
	 
    void PresentRenderer::RecordCommandBuffer(const RenderFrameContext& renderFrameContext, const Model* models, uint32_t modelCount)
    {
		// Pipeline
		vkCmdBindPipeline(renderFrameContext.GraphicsCommand, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline.GetPipelineHandle());

		vkCmdBindDescriptorSets(renderFrameContext.GraphicsCommand, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline.GetPipelineLayoutHandle(),
			0, 1, &m_descriptorSet, 0, nullptr);
		m_quadVertexBuffer.Bind(renderFrameContext.GraphicsCommand);
		m_quadIndexBuffer.Bind(renderFrameContext.GraphicsCommand);
		vkCmdDrawIndexed(renderFrameContext.GraphicsCommand, 6, 1, 0, 0, 0);
    }
}
