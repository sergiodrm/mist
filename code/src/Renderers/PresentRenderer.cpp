// Autogenerated code for vkmmc project
// Source file
#include "PresentRenderer.h"
#include "Debug.h"
#include "Shader.h"
#include "Globals.h"
#include "InitVulkanTypes.h"
#include "Framebuffer.h"
#include "VulkanRenderEngine.h"

namespace vkmmc
{
    void PresentRenderer::Init(const RendererCreateInfo& info)
    {
		// Render pass
        m_renderPass.Init(info.RContext, { info.Swapchain.GetImageFormat(), info.Swapchain.GetDepthFormat() });
		m_extent[0] = info.RContext.Width;
		m_extent[1] = info.RContext.Height;

		// Framebuffer
        uint32_t framebufferCount = info.Swapchain.GetImageCount();
        m_framebufferArray.resize(framebufferCount);
        for (uint32_t i = 0; i < framebufferCount; ++i)
        {
            m_framebufferArray[i] = FramebufferBuilder::Create()
                .AddAttachment(info.Swapchain.GetImageViewAt(i))
                .AddAttachment(info.Swapchain.GetDepthImageView())
                .Build(info.RContext.Device, m_renderPass.GetRenderPassHandle(), info.RContext.Width, info.RContext.Height);
        }

		// Descriptor set layout
		VkDescriptorSetLayoutBinding bindings[] =
		{
			{
				.binding = 0,
				.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
				.descriptorCount = 1,
				.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,
				.pImmutableSamplers = nullptr
			}
		};
		VkDescriptorSetLayoutCreateInfo layoutCreateInfo
		{
			.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
			.pNext = nullptr,
			.bindingCount = sizeof(bindings) / sizeof(VkDescriptorSetLayoutBinding),
			.pBindings = bindings
		};
		vkcheck(vkCreateDescriptorSetLayout(info.RContext.Device, &layoutCreateInfo, nullptr, &m_descriptorSetLayout));

		// Render pipeline
		VkDescriptorSetLayout setLayouts[] = { m_descriptorSetLayout };
		const uint32_t setLayoutCount = sizeof(setLayouts) / sizeof(VkDescriptorSetLayout);
		ShaderModuleLoadDescription shaderStageDescs[] =
		{
			{.ShaderFilePath = globals::PresentVertexShader, .Flags = VK_SHADER_STAGE_VERTEX_BIT},
			{.ShaderFilePath = globals::PresentFragmentShader, .Flags = VK_SHADER_STAGE_FRAGMENT_BIT}
		};

		VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo = vkinit::PipelineLayoutCreateInfo();
		pipelineLayoutCreateInfo.setLayoutCount = setLayoutCount;
		pipelineLayoutCreateInfo.pSetLayouts = setLayouts;
		pipelineLayoutCreateInfo.pushConstantRangeCount = info.ConstantRangeCount;
		pipelineLayoutCreateInfo.pPushConstantRanges = info.ConstantRange;
		m_pipeline = RenderPipeline::Create(
			info.RContext,
			m_renderPass,
			shaderStageDescs,
			sizeof(shaderStageDescs) / sizeof(ShaderModuleLoadDescription),
			pipelineLayoutCreateInfo,
			VertexInputLayout::GetBasicVertexLayout()
		);

		// Create screen quad
		struct QuadVertex { glm::vec3 Position; glm::vec2 TexCoords; };
		std::vector<QuadVertex> vertices
		{
			{{0.f, 0.f, 0.f}, {0.f, 1.f}},
			{{1.f, 1.f, 0.f}, {1.f, 0.f}},
			{{1.f, 0.f, 0.f}, {1.f, 1.f}},
			{{0.f, 1.f, 0.f}, {0.f, 0.f}},
		};
		std::vector<uint32_t> indices{ 0, 1, 2, 0, 3, 1 };
		BufferCreateInfo createInfo;
		createInfo.RContext = info.RContext;
		createInfo.Size = (uint32_t)vertices.size() * sizeof(QuadVertex);
		createInfo.Data = vertices.data();
		m_quadVertexBuffer.Init(createInfo);
		createInfo.Size = (uint32_t)indices.size() * sizeof(uint32_t);
		createInfo.Data = indices.data();
		m_quadIndexBuffer.Init(createInfo);

		// Create descriptor to bind image render
		VulkanRenderEngine* engine = IRenderEngine::GetRenderEngineAs<VulkanRenderEngine>();
		m_descriptorSet = engine->AllocateDescriptorSet(m_descriptorSetLayout);
		// Create sampler
		VkSamplerCreateInfo samplerInfo = vkinit::SamplerCreateInfo(VK_FILTER_NEAREST, VK_SAMPLER_ADDRESS_MODE_REPEAT);
		vkcheck(vkCreateSampler(info.RContext.Device, &samplerInfo, nullptr, &m_sampler));
    }

    void PresentRenderer::Destroy(const RenderContext& renderContext)
    {
		vkDestroySampler(renderContext.Device, m_sampler, nullptr);
		m_quadIndexBuffer.Destroy(renderContext);
		m_quadVertexBuffer.Destroy(renderContext);

		m_pipeline.Destroy(renderContext);
		vkDestroyDescriptorSetLayout(renderContext.Device, m_descriptorSetLayout, nullptr);
		for (VkFramebuffer it : m_framebufferArray)
			vkDestroyFramebuffer(renderContext.Device, it, nullptr);
		m_renderPass.Destroy(renderContext);
    }

    void PresentRenderer::RecordCommandBuffer(const RenderFrameContext& renderFrameContext, const Model* models, uint32_t modelCount)
    {
		//// Prepare render pass
		VkRenderPassBeginInfo renderPassInfo = {};
		renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
		renderPassInfo.pNext = nullptr;
		renderPassInfo.renderPass = m_renderPass.GetRenderPassHandle();
		renderPassInfo.renderArea.offset = { 0, 0 };
		renderPassInfo.renderArea.extent = { .width = m_extent[0], .height = m_extent[1] };
		renderPassInfo.framebuffer = renderFrameContext.Framebuffer;

		// Clear values
		VkClearValue clearValues[2];
		clearValues[0].color = { 0.2f, 0.2f, 0.f, 1.f };
		clearValues[1].depthStencil.depth = 1.f;
		renderPassInfo.clearValueCount = sizeof(clearValues) / sizeof(VkClearValue);
		renderPassInfo.pClearValues = clearValues;
		// Begin render pass
		vkCmdBeginRenderPass(renderFrameContext.GraphicsCommand, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);

		// Pipeline
		vkCmdBindPipeline(renderFrameContext.GraphicsCommand, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline.GetPipelineHandle());

		vkCmdBindDescriptorSets(renderFrameContext.GraphicsCommand, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline.GetPipelineLayoutHandle(),
			0, 1, &m_descriptorSet, 0, nullptr);
		m_quadVertexBuffer.Bind(renderFrameContext.GraphicsCommand);
		m_quadIndexBuffer.Bind(renderFrameContext.GraphicsCommand);
		vkCmdDrawIndexed(renderFrameContext.GraphicsCommand, 6, 1, 0, 0, 0);

		vkCmdEndRenderPass(renderFrameContext.GraphicsCommand);
    }

	void PresentRenderer::SetImageToRender(const RenderContext& renderContext, VkImageView imageView)
	{
		check(m_descriptorSet != VK_NULL_HANDLE);

		// Update descriptor
		VkDescriptorImageInfo imageInfo
		{
			.sampler = m_sampler,
			.imageView = imageView,
			.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
		};
		VkWriteDescriptorSet writeInfo
		{
			.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
			.pNext = nullptr,
			.dstSet = m_descriptorSet,
			.dstBinding = 0, 
			.dstArrayElement = 0,
			.descriptorCount = 1,
			.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
			.pImageInfo = &imageInfo
		};
		vkUpdateDescriptorSets(renderContext.Device, 1, &writeInfo, 0, nullptr);
	}
}
