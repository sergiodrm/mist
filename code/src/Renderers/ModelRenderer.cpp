// Autogenerated code for vkmmc project
// Source file
#include "ModelRenderer.h"
#include "Debug.h"
#include "InitVulkanTypes.h"
#include "Shader.h"
#include "Globals.h"
#include "VulkanRenderEngine.h"
#include "SceneImpl.h"

namespace vkmmc
{
    void ModelRenderer::Init(const RendererCreateInfo& info)
    {
		/**********************************/
		/** Pipeline layout and pipeline **/
		/**********************************/
		ShaderDescription shaderStageDescs[] =
		{
			{.Filepath = globals::BasicVertexShader, .Stage = VK_SHADER_STAGE_VERTEX_BIT},
			{.Filepath = globals::BasicFragmentShader, .Stage = VK_SHADER_STAGE_FRAGMENT_BIT}
		};
        m_renderPipeline = RenderPipeline::Create(
            info.RContext,
            info.RenderPass,
            0,
            shaderStageDescs,
            sizeof(shaderStageDescs) / sizeof(ShaderDescription),
            VertexInputLayout::GetStaticMeshVertexLayout()
        );
    }

    void ModelRenderer::Destroy(const RenderContext& renderContext)
    {
        m_renderPipeline.Destroy(renderContext);
    }

    void ModelRenderer::RecordCommandBuffer(const RenderFrameContext& renderFrameContext)
    {
        VkCommandBuffer cmd = renderFrameContext.GraphicsCommand;
        vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, m_renderPipeline.GetPipelineHandle());
        vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, m_renderPipeline.GetPipelineLayoutHandle(),
            0, 1, &renderFrameContext.GlobalDescriptorSet, 0, nullptr);

        if (renderFrameContext.PushConstantData)
        {
            check(renderFrameContext.PushConstantSize);
            vkCmdPushConstants(cmd, m_renderPipeline.GetPipelineLayoutHandle(),
                VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                renderFrameContext.PushConstantSize,
                renderFrameContext.PushConstantData);
        }

		Material lastMaterial;
		Mesh lastMesh;
		Scene* scene = renderFrameContext.Scene;
		const Model* models = scene->GetModelArray();
		uint32_t modelCount = scene->GetModelCount();
		for (uint32_t i = 0; i < modelCount; ++i)
		{
			const Model& model = models[i];
			for (uint32_t meshIndex = 0; meshIndex < model.m_meshArray.size(); ++meshIndex)
			{
				Mesh mesh = model.m_meshArray[meshIndex];
				Material material = model.m_materialArray[meshIndex];
				if (mesh.GetHandle().IsValid() && material.GetHandle().IsValid())
				{
					if (material != lastMaterial || !lastMaterial.GetHandle().IsValid())
					{
						lastMaterial = material;
						RenderHandle mtlHandle = material.GetHandle();
						if (mtlHandle.IsValid())
						{
							const MaterialRenderData& texData = scene->GetMaterialRenderData(mtlHandle);;
							vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS,
								m_renderPipeline.GetPipelineLayoutHandle(), 1, 1, &texData.Set,
								0, nullptr);
						}
					}

					if (lastMesh != mesh)
					{
						check(mesh.GetHandle().IsValid());
						const MeshRenderData& meshRenderData = scene->GetMeshRenderData(mesh.GetHandle());
						meshRenderData.VertexBuffer.Bind(cmd);
						meshRenderData.IndexBuffer.Bind(cmd);
						lastMesh = mesh;
					}
					vkCmdDrawIndexed(cmd, (uint32_t)lastMesh.GetIndexCount(), 1, 0, 0, i);
				}
			}
		}

    }

}
