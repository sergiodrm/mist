// Autogenerated code for vkmmc project
// Source file
#include "ModelRenderer.h"
#include "Debug.h"
#include "InitVulkanTypes.h"
#include "Shader.h"
#include "Globals.h"
#include "VulkanRenderEngine.h"
#include "SceneImpl.h"
#include "imgui_internal.h"

#include "DebugRenderer.h"

namespace vkmmc
{
	ModelRenderer::ModelRenderer() : IRendererBase(), m_activeLightsCount(0)
	{
		for (uint32_t i = 0; i < EnvironmentData::MaxLights; ++i)
			m_environmentData.Lights[i] = { .Position = {0.f, 0.f, 0.f}, .Radius = 10.f, .Color = {1.f, 1.f, 1.f}, .Compression = 0.5f, };
		m_environmentData.DirectionalLight = { .Direction = {0.f, -1.f, 0.f}, .Radius = 0.f, .Color = {0.01f, 0.01f, 0.05f}, .Compression = 0.f };
	}

	void ModelRenderer::Init(const RendererCreateInfo& info)
	{
		/**********************************/
		/** Pipeline layout and pipeline **/
		/**********************************/
		ShaderDescription shaderStageDescs[] =
		{
			{.Filepath = globals::BasicVertexShader, .Stage = VK_SHADER_STAGE_VERTEX_BIT},
			{.Filepath = globals::BasicFragmentShader, .Stage = VK_SHADER_STAGE_FRAGMENT_BIT}
		};
		m_renderPipeline = RenderPipeline::Create(
			info.RContext,
			info.RenderPass,
			0,
			shaderStageDescs,
			sizeof(shaderStageDescs) / sizeof(ShaderDescription),
			VertexInputLayout::GetStaticMeshVertexLayout()
		);

		m_frameData.resize(info.FrameUniformBufferArray.size());
		for (uint32_t i = 0; i < (uint32_t)info.FrameUniformBufferArray.size(); ++i)
		{
			UniformBuffer* uniformBuffer = info.FrameUniformBufferArray[i];
			uint32_t modelsSize = sizeof(glm::mat4) * VulkanRenderEngine::MaxRenderObjects;
			uint32_t modelsOffset = uniformBuffer->AllocUniform(info.RContext, "Models", modelsSize);
			VkDescriptorBufferInfo modelsDescInfo;
			modelsDescInfo.buffer = uniformBuffer->GetBuffer();
			modelsDescInfo.offset = modelsOffset;
			modelsDescInfo.range = modelsSize;
			uint32_t enviroSize = sizeof(EnvironmentData);
			uint32_t enviroOffset = uniformBuffer->AllocUniform(info.RContext, "Environment", enviroSize);
			VkDescriptorBufferInfo enviroDescInfo;
			enviroDescInfo.buffer = uniformBuffer->GetBuffer();
			enviroDescInfo.offset = enviroOffset;
			enviroDescInfo.range = enviroSize;

			DescriptorBuilder::Create(*info.LayoutCache, *info.DescriptorAllocator)
				.BindBuffer(0, modelsDescInfo, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_SHADER_STAGE_VERTEX_BIT)
				.BindBuffer(1, enviroDescInfo, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_FRAGMENT_BIT)
				.Build(info.RContext, m_frameData[i].GlobalSet);
		}

		m_environmentData.AmbientColor = glm::vec4(0.01f, 0.01f, 0.01f, 1.f);
	}

	void ModelRenderer::Destroy(const RenderContext& renderContext)
	{
		m_renderPipeline.Destroy(renderContext);
	}

	void ModelRenderer::RecordCommandBuffer(const RenderContext& renderContext, RenderFrameContext& renderFrameContext)
	{
		// Update buffers
		// TODO: Get camera position from scene view.
		m_environmentData.ViewPosition = glm::inverse(renderFrameContext.CameraData->View)[3];
		m_environmentData.ActiveLightsCount = (float)m_activeLightsCount;
		renderFrameContext.GlobalBuffer.SetUniform(renderContext, "Models", renderFrameContext.Scene->GetRawGlobalTransforms(), sizeof(glm::mat4) * renderFrameContext.Scene->Count());
		renderFrameContext.GlobalBuffer.SetUniform(renderContext, "Environment", &m_environmentData, sizeof(EnvironmentData));

		// Bind pipeline
		VkCommandBuffer cmd = renderFrameContext.GraphicsCommand;
		vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, m_renderPipeline.GetPipelineHandle());

		// Bind global descriptor sets
		VkDescriptorSet sets[] = { renderFrameContext.CameraDescriptorSet, m_frameData[renderFrameContext.FrameIndex].GlobalSet };
		uint32_t setCount = sizeof(sets) / sizeof(VkDescriptorSet);
		vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, m_renderPipeline.GetPipelineLayoutHandle(), 0, setCount, sets, 0, nullptr);

		// Push constants if needed
		if (renderFrameContext.PushConstantData)
		{
			check(renderFrameContext.PushConstantSize);
			vkCmdPushConstants(cmd, m_renderPipeline.GetPipelineLayoutHandle(),
				VK_SHADER_STAGE_FRAGMENT_BIT, 0,
				renderFrameContext.PushConstantSize,
				renderFrameContext.PushConstantData);
		}

		// Iterate scene graph to render models.
		Material lastMaterial;
		Mesh lastMesh;
		Scene* scene = renderFrameContext.Scene;
		const Model* models = scene->GetModelArray();
		uint32_t modelCount = scene->GetModelCount();
		for (uint32_t i = 0; i < modelCount; ++i)
		{
			const Model& model = models[i];
			for (uint32_t meshIndex = 0; meshIndex < model.m_meshArray.size(); ++meshIndex)
			{
				Mesh mesh = model.m_meshArray[meshIndex];
				Material material = model.m_materialArray[meshIndex];
				if (mesh.GetHandle().IsValid() && material.GetHandle().IsValid())
				{
					if (material != lastMaterial || !lastMaterial.GetHandle().IsValid())
					{
						lastMaterial = material;
						RenderHandle mtlHandle = material.GetHandle();
						if (mtlHandle.IsValid())
						{
							const MaterialRenderData& texData = scene->GetMaterialRenderData(mtlHandle);;
							vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS,
								m_renderPipeline.GetPipelineLayoutHandle(), 2, 1, &texData.Set,
								0, nullptr);
						}
					}

					if (lastMesh != mesh)
					{
						check(mesh.GetHandle().IsValid());
						const MeshRenderData& meshRenderData = scene->GetMeshRenderData(mesh.GetHandle());
						meshRenderData.VertexBuffer.Bind(cmd);
						meshRenderData.IndexBuffer.Bind(cmd);
						lastMesh = mesh;
					}
					vkCmdDrawIndexed(cmd, (uint32_t)lastMesh.GetIndexCount(), 1, 0, 0, i);
				}
			}
		}
	}

	void ModelRenderer::ImGuiDraw()
	{
		ImGui::Begin("Environment");
		auto utilDragFloat = [](const char* label, uint32_t id, float* data, uint32_t count, bool asColor, float diff = 1.f, float minLimit = 0.f, float maxLimit = 0.f)
			{
				ImGui::Columns(2);
				ImGui::Text(label);
				ImGui::NextColumn();
				char buff[64];
				sprintf_s(buff, "##%s%u", label, id);
				bool r = false;
				switch (count)
				{
				case 1: r = ImGui::DragFloat(buff, data, diff, minLimit, maxLimit); break;
				case 2: r = ImGui::DragFloat2(buff, data, diff, minLimit, maxLimit); break;
				case 3: r = asColor ? ImGui::ColorEdit3(buff, data) : ImGui::DragFloat3(buff, data, diff, minLimit, maxLimit); break;
				case 4: r = asColor ? ImGui::ColorEdit4(buff, data) : ImGui::DragFloat4(buff, data, diff, minLimit, maxLimit); break;
				}
				ImGui::NextColumn();
				ImGui::Columns();
				return r;
			};
		utilDragFloat("Ambient color", 0, &m_environmentData.AmbientColor[0], 3, true);

		if (ImGui::CollapsingHeader("Directional light"))
		{
			utilDragFloat("Direction", EnvironmentData::MaxLights, &m_environmentData.DirectionalLight.Direction[0], 3, false, 0.02f, -1.f, 1.f);
			utilDragFloat("Color", EnvironmentData::MaxLights, &m_environmentData.DirectionalLight.Color[0], 3, true);
			rdbg::DeferredDrawLine(glm::vec3(0.f), m_environmentData.DirectionalLight.Direction, glm::vec3(1.f));
		}
		if (ImGui::CollapsingHeader("Point lights"))
		{
			ImGui::SliderInt("Active point lights", &m_activeLightsCount, 0, (int32_t)EnvironmentData::MaxLights, "%d");
			for (uint32_t i = 0; i < (uint32_t)m_activeLightsCount; ++i)
			{
				char buff[32];
				sprintf_s(buff, "PointLight_%u", i);
				if (ImGui::CollapsingHeader(buff))
				{
					utilDragFloat("Position", i, &m_environmentData.Lights[i].Position[0], 3, false);
					utilDragFloat("Color", i, &m_environmentData.Lights[i].Color[0], 3, true);
					utilDragFloat("Radius", i, &m_environmentData.Lights[i].Radius, 1, false, 0.5f, 0.f, FLT_MAX);
					utilDragFloat("Compression", i, &m_environmentData.Lights[i].Compression, 1, false, 0.5f, 0.5f, FLT_MAX);

					rdbg::DeferredDrawAxis(m_environmentData.Lights[i].Position, glm::vec3(0.f), glm::vec3(1.f));
					rdbg::DeferredDrawSphere(m_environmentData.Lights[i].Position, m_environmentData.Lights[i].Radius, m_environmentData.Lights[i].Color);
				}
			}
		}
		ImGui::End();
	}
}
