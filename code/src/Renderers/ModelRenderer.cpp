// Autogenerated code for vkmmc project
// Source file
#include "ModelRenderer.h"
#include "Debug.h"
#include "InitVulkanTypes.h"
#include "Shader.h"
#include "Globals.h"
#include "VulkanRenderEngine.h"

namespace vkmmc
{
    void ModelRenderer::Init(const RendererCreateInfo& info)
    {
        /***************/
		/** Render pass **/
        /***************/
        RenderPassSpecification rpInfo;
        rpInfo.ColorAttachmentFormat = VK_FORMAT_R8G8B8A8_SRGB;
        rpInfo.DepthStencilAttachmentFormat = VK_FORMAT_D32_SFLOAT;
        m_renderPass.Init(info.RContext, rpInfo);

		/*****************/
		/** Framebuffer **/
		/*****************/
        FramebufferCreateInfo fbInfo;
        fbInfo.RenderPass = m_renderPass.GetRenderPassHandle();
        fbInfo.Width = info.RContext.Width;
        fbInfo.Height = info.RContext.Height;
        fbInfo.AttachmentTypes.push_back(EAttachmentType::FRAMEBUFFER_COLOR_ATTACHMENT);
        fbInfo.AttachmentTypes.push_back(EAttachmentType::FRAMEBUFFER_DEPTH_STENCIL_ATTACHMENT);
        m_framebuffer.Init(info.RContext, fbInfo);

		/***************************/
		/** Descriptor set layout **/
		/***************************/
        VkDescriptorSetLayoutBinding bindings[] =
        {
            {
                .binding = 0,
                .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
                .descriptorCount = 3,
                .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT,
                .pImmutableSamplers = nullptr
            }
        };
        VkDescriptorSetLayoutCreateInfo layoutCreateInfo
        {
            .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
            .pNext = nullptr,
            .bindingCount = sizeof(bindings) / sizeof(VkDescriptorSetLayoutBinding),
            .pBindings = bindings
        };
        vkcheck(vkCreateDescriptorSetLayout(info.RContext.Device, &layoutCreateInfo, nullptr, &m_descriptorSetLayout));
        VkDescriptorSetLayout setLayouts[] = { info.GlobalDescriptorSetLayout, m_descriptorSetLayout };
        const uint32_t setLayoutCount = sizeof(setLayouts) / sizeof(VkDescriptorSetLayout);

		/**********************************/
		/** Pipeline layout and pipeline **/
		/**********************************/
		ShaderModuleLoadDescription shaderStageDescs[] =
		{
			{.ShaderFilePath = globals::BasicVertexShaders, .Flags = VK_SHADER_STAGE_VERTEX_BIT},
			{.ShaderFilePath = globals::BasicFragmentShaders, .Flags = VK_SHADER_STAGE_FRAGMENT_BIT}
		};

        VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo = vkinit::PipelineLayoutCreateInfo();
        pipelineLayoutCreateInfo.setLayoutCount = setLayoutCount;
        pipelineLayoutCreateInfo.pSetLayouts = setLayouts;
        pipelineLayoutCreateInfo.pushConstantRangeCount = info.ConstantRangeCount;
        pipelineLayoutCreateInfo.pPushConstantRanges = info.ConstantRange;
        m_renderPipeline = RenderPipeline::Create(
            info.RContext,
            m_renderPass,
            shaderStageDescs,
            sizeof(shaderStageDescs) / sizeof(ShaderModuleLoadDescription),
            pipelineLayoutCreateInfo,
            VertexInputLayout::GetStaticMeshVertexLayout()
        );
    }

    void ModelRenderer::Destroy(const RenderContext& renderContext)
    {
        m_renderPipeline.Destroy(renderContext);
        vkDestroyDescriptorSetLayout(renderContext.Device, m_descriptorSetLayout, nullptr);
        m_framebuffer.Destroy(renderContext);
        m_renderPass.Destroy(renderContext);
    }

    void ModelRenderer::RecordCommandBuffer(const RenderFrameContext& renderFrameContext, const Model* models, uint32_t modelCount)
    {
        BeginRenderPass(renderFrameContext);

        VkCommandBuffer cmd = renderFrameContext.GraphicsCommand;
        vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, m_renderPipeline.GetPipelineHandle());
        vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, m_renderPipeline.GetPipelineLayoutHandle(),
            0, 1, &renderFrameContext.GlobalDescriptorSet, 0, nullptr);

        if (renderFrameContext.PushConstantData)
        {
            check(renderFrameContext.PushConstantSize);
            vkCmdPushConstants(cmd, m_renderPipeline.GetPipelineLayoutHandle(),
                VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                renderFrameContext.PushConstantSize,
                renderFrameContext.PushConstantData);
        }

		Material lastMaterial;
		Mesh lastMesh;
		for (uint32_t i = 0; i < modelCount; ++i)
		{
			const Model& model = models[i];
			for (uint32_t meshIndex = 0; meshIndex < model.m_meshArray.size(); ++meshIndex)
			{
				Mesh mesh = model.m_meshArray[meshIndex];
				Material material = model.m_materialArray[meshIndex];
				if (mesh.GetHandle().IsValid() && material.GetHandle().IsValid())
				{
					if (material != lastMaterial || !lastMaterial.GetHandle().IsValid())
					{
						lastMaterial = material;
						RenderHandle mtlHandle = material.GetHandle();
						if (mtlHandle.IsValid())
						{
                            const void* internalData = material.GetInternalData();
							const MaterialRenderData& texData = *static_cast<const MaterialRenderData*>(internalData);
							vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS,
								m_renderPipeline.GetPipelineLayoutHandle(), 1, 1, &texData.Set,
								0, nullptr);
						}
					}

					if (lastMesh != mesh)
					{
						check(mesh.GetHandle().IsValid());
                        const void* internalData = mesh.GetInternalData();
						const MeshRenderData& meshRenderData = *static_cast<const MeshRenderData*>(internalData);
						meshRenderData.VertexBuffer.Bind(cmd);
						meshRenderData.IndexBuffer.Bind(cmd);
						lastMesh = mesh;
					}
					vkCmdDrawIndexed(cmd, (uint32_t)lastMesh.GetIndexCount(), 1, 0, 0, i);
					//vkmmc_debug::GRenderStats.m_drawCalls++;
					//vkmmc_debug::GRenderStats.m_trianglesCount += (uint32_t)mesh.GetVertexCount() / 3;
				}
			}
		}

        EndRenderPass(renderFrameContext);
    }

    void ModelRenderer::BeginRenderPass(const RenderFrameContext& renderFrameContext)
    {
		// Prepare render pass
		VkRenderPassBeginInfo renderPassInfo = {};
		renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
		renderPassInfo.pNext = nullptr;
		renderPassInfo.renderPass = m_renderPass.GetRenderPassHandle();
		renderPassInfo.renderArea.offset = { 0, 0 };
		renderPassInfo.renderArea.extent = { .width = m_framebuffer.GetWidth(), .height = m_framebuffer.GetHeight() };
		renderPassInfo.framebuffer = m_framebuffer.GetFramebufferHandle();

		// Clear values
		VkClearValue clearValues[2];
		clearValues[0].color = { 0.2f, 0.2f, 0.f, 1.f };
		clearValues[1].depthStencil.depth = 1.f;
		renderPassInfo.clearValueCount = sizeof(clearValues) / sizeof(VkClearValue);
		renderPassInfo.pClearValues = clearValues;
		// Begin render pass
		vkCmdBeginRenderPass(renderFrameContext.GraphicsCommand, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);
    }

    void ModelRenderer::EndRenderPass(const RenderFrameContext& renderFrameContext)
    {
        vkCmdEndRenderPass(renderFrameContext.GraphicsCommand);
    }
}
