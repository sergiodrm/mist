// Autogenerated code for vkmmc project
// Header file

#pragma once
#include "RendererBase.h"
#include "Texture.h"
#include <glm/glm.hpp>

namespace vkmmc
{
	class Scene;

	

	class ShadowMapPipeline
	{
		struct FrameData
		{
			VkDescriptorSet ModelSet;
			VkDescriptorSet DepthMVPSet;
		};
	public:
		enum EShadowMapProjectionType
		{
			PROJECTION_PERSPECTIVE,
			PROJECTION_ORTHOGRAPHIC,
		};

		ShadowMapPipeline();
		~ShadowMapPipeline();

		void Init(const RenderContext& renderContext, VkRenderPass renderPass, DescriptorAllocator* descriptorAllocator, DescriptorLayoutCache* layoutCache);
		void Destroy(const RenderContext& renderContext);

		void AddFrameData(const RenderContext& renderContext, UniformBuffer* buffer, DescriptorAllocator* descAllocator, DescriptorLayoutCache* layoutCache);

		void SetClip(float nearClip, float farClip);
		glm::mat4 GetProjection(EShadowMapProjectionType projType) const;
		void SetProjection(float fov, float aspectRatio);
		void SetProjection(float minX, float maxX, float minY, float maxY);
		void SetupLight(uint32_t lightIndex, const glm::vec3& lightPos, const glm::vec3& lightRot, EShadowMapProjectionType projType);
		void FlushToUniformBuffer(const RenderContext& renderContext, UniformBuffer* buffer);
		void RenderShadowMap(VkCommandBuffer cmd, const Scene* scene, uint32_t frameIndex, uint32_t lightIndex);
		const glm::mat4& GetDepthVP(uint32_t index) const;
		uint32_t GetBufferSize() const;

		void ImGuiDraw(bool createWindow = false);
	private:
		// Shader shadowmap pipeline
		RenderPipeline m_pipeline;
		// Cache for save depth view projection data until flush to gpu buffer.
		glm::mat4 m_depthMVPCache[globals::MaxShadowMapAttachments];
		// Projection params
		float m_perspectiveParams[2];
		float m_orthoParams[4];
		float m_clip[2];
		// Per frame info
		std::vector<FrameData> m_frameData;
	};

	class ShadowMapRenderer : public IRendererBase
	{
		struct FrameData
		{
			VkDescriptorSet DebugShadowMapTextureSet[globals::MaxShadowMapAttachments];
		};
	public:
		ShadowMapRenderer();
		virtual void Init(const RendererCreateInfo& info) override;
		virtual void Destroy(const RenderContext& renderContext) override;
		virtual void PrepareFrame(const RenderContext& renderContext, RenderFrameContext& renderFrameContext) override;
		virtual void RecordCmd(const RenderContext& renderContext, const RenderFrameContext& renderFrameContext, uint32_t attachmentIndex) override;
		virtual void ImGuiDraw() override;
	private:
		ShadowMapPipeline m_shadowMapPipeline;
		Sampler m_debugSampler;
		FrameData m_frameData[globals::MaxOverlappedFrames];
	};

	class LightingRenderer : public IRendererBase
	{
		struct RendererFrameData
		{
			// Camera, models and environment
			VkDescriptorSet PerFrameSet;
			VkDescriptorSet ModelSet;
		};
	public:
		LightingRenderer();
		virtual void Init(const RendererCreateInfo& info) override;
		virtual void Destroy(const RenderContext& renderContext) override;
		virtual void PrepareFrame(const RenderContext& renderContext, RenderFrameContext& renderFrameContext) override;
		virtual void RecordCmd(const RenderContext& renderContext, const RenderFrameContext& renderFrameContext, uint32_t attachmentIndex) override;
		virtual void ImGuiDraw() override;

	protected:

	protected:
		// Render State
		RenderPipeline m_renderPipeline;

		std::vector<RendererFrameData> m_frameData;
		
		VkSampler m_depthMapSampler;
		bool m_debugCameraDepthMapping;
	};
}
