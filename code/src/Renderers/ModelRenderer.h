// Autogenerated code for vkmmc project
// Header file

#pragma once
#include "RendererBase.h"
#include "Texture.h"
#include "RenderTarget.h"
#include <glm/glm.hpp>

namespace vkmmc
{
	class Scene;

	

	class ShadowMapPipeline
	{
		struct FrameData
		{
			VkDescriptorSet ModelSet;
			VkDescriptorSet DepthMVPSet;
		};
	public:
		enum EShadowMapProjectionType
		{
			PROJECTION_PERSPECTIVE,
			PROJECTION_ORTHOGRAPHIC,
		};

		ShadowMapPipeline();
		~ShadowMapPipeline();

		void Init(const RenderContext& renderContext, const RenderTarget* renderTarget);
		void Destroy(const RenderContext& renderContext);

		void AddFrameData(const RenderContext& renderContext, UniformBuffer* buffer);

		void SetClip(float nearClip, float farClip);
		glm::mat4 GetProjection(EShadowMapProjectionType projType) const;
		void SetProjection(float fov, float aspectRatio);
		void SetProjection(float minX, float maxX, float minY, float maxY);
		void SetupLight(uint32_t lightIndex, const glm::vec3& lightPos, const glm::vec3& lightRot, EShadowMapProjectionType projType);
		void FlushToUniformBuffer(const RenderContext& renderContext, UniformBuffer* buffer);
		void RenderShadowMap(VkCommandBuffer cmd, const Scene* scene, uint32_t frameIndex, uint32_t lightIndex);
		const glm::mat4& GetDepthVP(uint32_t index) const;
		void SetDepthVP(uint32_t index, const glm::mat4& mat);
		uint32_t GetBufferSize() const;

		void ImGuiDraw(bool createWindow = false);
	private:
		// Shader shadowmap pipeline
		ShaderProgram* m_shader;
		// Cache for save depth view projection data until flush to gpu buffer.
		glm::mat4 m_depthMVPCache[globals::MaxShadowMapAttachments];
		// Projection params
		float m_perspectiveParams[2];
		float m_orthoParams[4];
		float m_clip[2];
		// Per frame info
		std::vector<FrameData> m_frameData;
	};

	class ShadowMapRenderer : public IRendererBase
	{
		struct FrameData
		{
			tArray<RenderTarget, globals::MaxShadowMapAttachments> RenderTargetArray;
			VkDescriptorSet DebugShadowMapTextureSet[globals::MaxShadowMapAttachments];
		};
	public:
		ShadowMapRenderer();
		virtual void Init(const RendererCreateInfo& info) override;
		virtual void Destroy(const RenderContext& renderContext) override;
		virtual void PrepareFrame(const RenderContext& renderContext, RenderFrameContext& renderFrameContext) override;
		virtual void RecordCmd(const RenderContext& renderContext, const RenderFrameContext& renderFrameContext, uint32_t attachmentIndex) override;
		virtual void ImGuiDraw() override;
		virtual VkImageView GetRenderTarget(uint32_t currentFrameIndex, uint32_t attachmentIndex) const override;
		virtual VkImageView GetDepthBuffer(uint32_t currentFrameIndex, uint32_t attachmentIndex) const override;
	private:
		ShadowMapPipeline m_shadowMapPipeline;
		Sampler m_debugSampler;
		FrameData m_frameData[globals::MaxOverlappedFrames];
		uint32_t m_attachmentIndexBits;
	};

	class LightingRenderer : public IRendererBase
	{
		struct FrameData
		{
			RenderTarget RT;

			// Camera, models and environment
			VkDescriptorSet PerFrameSet;
			VkDescriptorSet ModelSet;
		};
	public:
		LightingRenderer();
		virtual void Init(const RendererCreateInfo& info) override;
		virtual void Destroy(const RenderContext& renderContext) override;
		virtual void PrepareFrame(const RenderContext& renderContext, RenderFrameContext& renderFrameContext) override;
		virtual void RecordCmd(const RenderContext& renderContext, const RenderFrameContext& renderFrameContext, uint32_t attachmentIndex) override;
		virtual void ImGuiDraw() override;
		virtual VkImageView GetRenderTarget(uint32_t currentFrameIndex, uint32_t attachmentIndex) const override;
		virtual VkImageView GetDepthBuffer(uint32_t currentFrameIndex, uint32_t attachmentIndex) const override;
	protected:

	protected:
		// Render State
		ShaderProgram* m_shader;

		tArray<FrameData, globals::MaxOverlappedFrames> m_frameData;
		
		Sampler m_depthMapSampler;
		bool m_debugCameraDepthMapping;
	};
}
