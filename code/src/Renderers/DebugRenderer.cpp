// Autogenerated code for vkmmc project
// Source file
#include "DebugRenderer.h"
#include "Debug.h"
#include "InitVulkanTypes.h"
#include "Shader.h"
#include "Globals.h"
#include "VulkanRenderEngine.h"

namespace vkmmc
{
    void DebugRenderer::Init(const RendererCreateInfo& info)
    {
		/***************************/
		/** Descriptor set layout **/
		/***************************/
		DescriptorSetLayoutBuilder::Create(*info.LayoutCache)
			.AddBinding(0, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_FRAGMENT_BIT, 1)
			.Build(info.RContext, &m_descriptorSetLayout);
        VkDescriptorSetLayout setLayouts[] = { info.GlobalDescriptorSetLayout, m_descriptorSetLayout };
        const uint32_t setLayoutCount = sizeof(setLayouts) / sizeof(VkDescriptorSetLayout);

		/**********************************/
		/** Pipeline layout and pipeline **/
		/**********************************/
        VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo = vkinit::PipelineLayoutCreateInfo();
        pipelineLayoutCreateInfo.setLayoutCount = setLayoutCount;
        pipelineLayoutCreateInfo.pSetLayouts = setLayouts;
        pipelineLayoutCreateInfo.pushConstantRangeCount = info.ConstantRangeCount;
        pipelineLayoutCreateInfo.pPushConstantRanges = info.ConstantRange;
		ShaderModuleLoadDescription shaderStageDescs[] =
		{
			{.ShaderFilePath = globals::LineVertexShader, .Flags = VK_SHADER_STAGE_VERTEX_BIT},
			{.ShaderFilePath = globals::LineFragmentShader, .Flags = VK_SHADER_STAGE_FRAGMENT_BIT}
		};
        std::vector<VkShaderModule> modules;
        ShaderCompiler compiler(shaderStageDescs, 2);
        compiler.ProcessReflectionProperties();
        compiler.Compile(info.RContext, modules);

        RenderPipelineBuilder builder(info.RContext);
        builder.InputDescription = VertexInputLayout::BuildVertexInputLayout({ EAttributeType::Float3 });
        builder.ShaderStages.push_back(vkinit::PipelineShaderStageCreateInfo(VK_SHADER_STAGE_VERTEX_BIT, modules[0]));
        builder.ShaderStages.push_back(vkinit::PipelineShaderStageCreateInfo(VK_SHADER_STAGE_FRAGMENT_BIT, modules[1]));
        builder.LayoutInfo = pipelineLayoutCreateInfo;
        builder.Topology = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;
        m_renderPipeline = builder.Build(info.RenderPass);
        for (VkShaderModule it : modules)
            vkDestroyShaderModule(info.RContext.Device, it, nullptr);
        modules.clear();

		// Uniform descriptor
        glm::vec4 color = { 1.f, 0.f, 0.f, 1.f };
		m_uniformBuffer = Memory::CreateBuffer(info.RContext.Allocator, sizeof(glm::vec4),
			VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VMA_MEMORY_USAGE_CPU_TO_GPU);
        Memory::MemCopyDataToBuffer(info.RContext.Allocator, m_uniformBuffer.Alloc, &color, sizeof(glm::vec4));
		VkDescriptorBufferInfo bufferInfo;
		bufferInfo.buffer = m_uniformBuffer.Buffer;
		bufferInfo.offset = 0;
		bufferInfo.range = sizeof(glm::vec4);
		DescriptorBuilder::Create(*info.LayoutCache, *info.DescriptorAllocator)
			.BindBuffer(0, bufferInfo, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_SHADER_STAGE_FRAGMENT_BIT)
			.Build(info.RContext, m_uniformSet);

        // VertexBuffer
        glm::vec3 pos[2] = { glm::vec3{0.f}, glm::vec3{10.f} };
        BufferCreateInfo vbInfo;
        vbInfo.RContext = info.RContext;
        vbInfo.Size = sizeof(glm::vec3) * 2;
        vbInfo.Data = pos;
        m_lineVertexBuffer.Init(vbInfo);
    }

    void DebugRenderer::Destroy(const RenderContext& renderContext)
    {
        m_lineVertexBuffer.Destroy(renderContext);
        Memory::DestroyBuffer(renderContext.Allocator, m_uniformBuffer);
        m_renderPipeline.Destroy(renderContext);
    }

    void DebugRenderer::RecordCommandBuffer(const RenderFrameContext& renderFrameContext, const Model* models, uint32_t modelCount)
    {
        vkCmdBindPipeline(renderFrameContext.GraphicsCommand, VK_PIPELINE_BIND_POINT_GRAPHICS, m_renderPipeline.GetPipelineHandle());
        VkDescriptorSet sets[] = { renderFrameContext.GlobalDescriptorSet, m_uniformSet };
        uint32_t setCount = sizeof(sets) / sizeof(VkDescriptorSet);
        vkCmdBindDescriptorSets(renderFrameContext.GraphicsCommand, VK_PIPELINE_BIND_POINT_GRAPHICS,
            m_renderPipeline.GetPipelineLayoutHandle(), 0, 2, sets, 0, nullptr);
        m_lineVertexBuffer.Bind(renderFrameContext.GraphicsCommand);
        vkCmdDraw(renderFrameContext.GraphicsCommand, 2, 1, 0, 0);
    }

}
