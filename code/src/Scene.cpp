// Autogenerated code for vkmmc project
// Source file
#include "Scene.h"
#include "Debug.h"

namespace vkmmc
{
    RenderObject Scene::NewRenderObject(RenderObject parent)
    {
        // Generate new node in all basics structures
        RenderObject node = (uint32_t)m_hierarchy.size();
        m_localTransforms.push_back(glm::mat4(1.f));
        m_globalTransforms.push_back(glm::mat4(1.f));
        m_names.push_back("");
        m_hierarchy.push_back({ .Parent = parent });

        // Connect siblings
        if (parent.IsValid())
        {
            check(parent.Id < (uint32_t)m_hierarchy.size());
            RenderObject firstSibling = m_hierarchy[parent].Child;
            if (firstSibling.IsValid())
            {
                RenderObject sibling;
                for (sibling = firstSibling; 
                    m_hierarchy[sibling].Sibling.IsValid(); 
                    sibling = m_hierarchy[sibling].Sibling);
                m_hierarchy[sibling].Sibling = node;
            }
            else
            {
                m_hierarchy[parent].Child = node;
            }
        }

        m_hierarchy[node].Level = parent.IsValid() ? m_hierarchy[parent].Level + 1 : 0;
        m_hierarchy[node].Child = RenderObject::InvalidId;
        m_hierarchy[node].Sibling = RenderObject::InvalidId;
        return node;
    }

    const Model* Scene::GetModel(RenderObject renderObject) const
    {
        check(renderObject.Id < (uint32_t)m_hierarchy.size());
        check(m_modelMap.contains(renderObject));
        uint32_t index = m_modelMap.at(renderObject);
        return &m_modelArray.at(renderObject.Id);
    }

    void Scene::SetModel(RenderObject renderObject, const Model& model)
    {
        check(renderObject.Id < (uint32_t)m_hierarchy.size());
        if (m_modelMap.contains(renderObject))
        {
            uint32_t index = m_modelMap[renderObject];
            m_modelArray[index] = model;
        }
        else
        {
            uint32_t index = (uint32_t)m_modelArray.size();
            m_modelArray.push_back(model);
            m_modelMap[renderObject] = index;
        }
    }

    RenderObject Scene::GetRoot() const
    {
        RenderObject root = 0;
        for (; m_hierarchy[root].Parent.IsValid(); root = m_hierarchy[root].Parent);
        return root;
    }

    void Scene::SetRenderObjectName(RenderObject renderObject, const char* name)
    {
		check(renderObject.Id < (uint32_t)m_hierarchy.size());
        m_names[renderObject] = name;
    }

	const glm::mat4& Scene::GetTransform(RenderObject renderObject) const
	{
        check(renderObject.Id < (uint32_t)m_hierarchy.size());
        return m_localTransforms[renderObject.Id];
	}

    void Scene::SetTransform(RenderObject renderObject, const glm::mat4& transform)
    {
        check(renderObject.Id < (uint32_t)m_hierarchy.size());
        m_localTransforms[renderObject] = transform;
        MarkAsDirty(renderObject);
    }

    void Scene::MarkAsDirty(RenderObject renderObject)
    {
        check(renderObject.Id < (uint32_t)m_hierarchy.size());
        int32_t level = m_hierarchy[renderObject].Level;
        m_dirtyNodes[level].push_back(renderObject);
        for (RenderObject child = m_hierarchy[renderObject].Child; child.IsValid(); child = m_hierarchy[child].Sibling)
            MarkAsDirty(child);
    }

    void Scene::RecalculateTransforms()
    {
        // Process root level first
        if (!m_dirtyNodes[0].empty())
        {
            int32_t rootNode = m_dirtyNodes[0][0];
            m_globalTransforms[rootNode] = m_localTransforms[rootNode];
            m_dirtyNodes[0].clear();
        }
        // Iterate over the deeper levels
        for (uint32_t level = 1; level < MaxNodeLevel && !m_dirtyNodes[level].empty(); ++level)
        {
            for (uint32_t nodeIndex = 0; nodeIndex < m_dirtyNodes[level].size(); ++nodeIndex)
            {
                int32_t node = m_dirtyNodes[level][nodeIndex];
                int32_t parentNode = m_hierarchy[node].Parent;
                m_globalTransforms[node] = m_globalTransforms[parentNode] * m_localTransforms[node];
            }
            m_dirtyNodes[level].clear();
        }
    }

    const Model* Scene::GetModelArray() const
    {
        return m_modelArray.data();
    }

    uint32_t Scene::GetModelCount() const
    {
        return (uint32_t)m_modelArray.size();
    }

    const glm::mat4* Scene::GetRawGlobalTransforms() const
    {
        // Dirty check, must be clean
        for (uint32_t i = 0; i < MaxNodeLevel; ++i)
            check(m_dirtyNodes[i].empty());
        return m_globalTransforms.data();
    }
}
