// Autogenerated code for vkmmc project
// Source file
#include "Framebuffer.h"
#include "Debug.h"
#include "Memory.h"
#include "RenderTypes.h"
#include "InitVulkanTypes.h"
#include "RenderContext.h"



namespace vkmmc
{   
    Framebuffer::Builder Framebuffer::Builder::Create(const RenderContext& renderContext, uint32_t width, uint32_t height)
    {
        Builder builder(renderContext);
        builder.m_width = width;
        builder.m_height = height;
        return builder;
    }

    Framebuffer::Builder& Framebuffer::Builder::AddAttachment(VkImageView imageView, bool freeOnDestroy)
    {
        check(m_attachments.size() < 8); // m_cleanFlags maximum capacity
        if (freeOnDestroy)
            MarkToClean((uint32_t)m_attachments.size());
        m_attachments.push_back(imageView);
        return *this;
    }

    Framebuffer::Builder& Framebuffer::Builder::CreateColorAttachment(EFormat fmt)
    {
		VkExtent3D extent = { m_width, m_height, 1 };
		VkFormat format = types::FormatType(fmt);

        VkImageCreateInfo imageInfo = vkinit::ImageCreateInfo(format, 
            VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
            extent);
        AllocatedImage image = Memory::CreateImage(m_renderContext.Allocator, imageInfo, MEMORY_USAGE_GPU);
		m_imageArray.push_back(image);

		VkImageViewCreateInfo viewInfo = vkinit::ImageViewCreateInfo(format, image.Image, VK_IMAGE_ASPECT_COLOR_BIT);
        VkImageView view;
		vkcheck(vkCreateImageView(m_renderContext.Device, &viewInfo, nullptr, &view));
        MarkToClean((uint32_t)m_attachments.size());
        return AddAttachment(view);
    }

    Framebuffer::Builder& Framebuffer::Builder::CreateDepthStencilAttachment(EFormat fmt)
    {
		// Create depth buffer
		VkExtent3D depthExtent = { m_width, m_height, 1 };
		VkFormat depthFormat = types::FormatType(fmt);
		VkImageCreateInfo imageInfo = vkinit::ImageCreateInfo(depthFormat,
            VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
            depthExtent);
		AllocatedImage image = Memory::CreateImage(m_renderContext.Allocator, imageInfo, MEMORY_USAGE_GPU);
        m_imageArray.push_back(image);

		// Image view
		VkImageViewCreateInfo viewInfo = vkinit::ImageViewCreateInfo(depthFormat, image.Image, VK_IMAGE_ASPECT_DEPTH_BIT);
        VkImageView view;
		vkcheck(vkCreateImageView(m_renderContext.Device, &viewInfo, nullptr, &view));

        MarkToClean((uint32_t)m_attachments.size());
        return AddAttachment(view);
    }

    Framebuffer Framebuffer::Builder::Build(VkRenderPass renderPass)
    {
		VkFramebufferCreateInfo info
		{
			.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
			.pNext = nullptr,
			.renderPass = renderPass,
			.attachmentCount = (uint32_t)m_attachments.size(),
			.pAttachments = m_attachments.data(),
			.width = m_width,
			.height = m_height,
			.layers = 1
		};
		VkFramebuffer framebufferHandle;
		vkcheck(vkCreateFramebuffer(m_renderContext.Device, &info, nullptr, &framebufferHandle));

        Framebuffer framebuffer;
        framebuffer.m_imageArray = std::move(m_imageArray);
        framebuffer.m_atttachmentViewArray = std::move(m_attachments);
        framebuffer.m_width = m_width;
        framebuffer.m_height = m_height;
        framebuffer.m_cleanFlags = m_cleanFlags;
        framebuffer.m_framebuffer = framebufferHandle;
		return framebuffer;
    }

    void Framebuffer::Builder::MarkToClean(uint32_t index)
    {
        m_cleanFlags |= BIT_N(index);
    }

    Framebuffer::Builder::Builder(const RenderContext& renderContext) : m_renderContext(renderContext), m_cleanFlags(0) {}

    void Framebuffer::Destroy(const RenderContext& renderContext)
    {
        for (uint32_t i = 0; i < m_imageArray.size(); ++i)
        {
            Memory::DestroyImage(renderContext.Allocator, m_imageArray[i]);
        }
        for (uint32_t i = 0; i < m_atttachmentViewArray.size(); ++i)
        {
            if (m_cleanFlags & BIT_N(i))
                vkDestroyImageView(renderContext.Device, m_atttachmentViewArray[i], nullptr);
        }
        vkDestroyFramebuffer(renderContext.Device, m_framebuffer, nullptr);
    }

    VkFramebuffer Framebuffer::GetFramebufferHandle() const
    {
        return m_framebuffer;
    }
}
