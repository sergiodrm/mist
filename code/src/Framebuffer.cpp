// Autogenerated code for Mist project
// Source file
#include "Framebuffer.h"
#include "Debug.h"
#include "Memory.h"
#include "RenderTypes.h"
#include "InitVulkanTypes.h"
#include "RenderContext.h"



namespace Mist
{

    Framebuffer::Builder::Builder(const RenderContext& renderContext, const tExtent3D& extent)
        : m_renderContext(renderContext), m_extent(extent), m_cleanFlags(0)
    {    }

    Framebuffer::Builder::~Builder()
    {
        check(m_attachments.empty());
        check(m_imageArray.empty());
    }

    void Framebuffer::Builder::AddAttachment(VkImageView imageView, bool freeOnDestroy)
    {
        if (freeOnDestroy)
            MarkToClean((uint32_t)m_attachments.size());
        m_attachments.push_back(imageView);
    }

    void Framebuffer::Builder::CreateAttachment(EFormat format, EImageUsage usage)
    {
        VkImageAspectFlags aspectFlags = 0;
        if (usage & IMAGE_USAGE_COLOR_ATTACHMENT_BIT)
            aspectFlags = VK_IMAGE_ASPECT_COLOR_BIT;
        else if (usage & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)
        {
            aspectFlags = VK_IMAGE_ASPECT_DEPTH_BIT;
        }
        check(aspectFlags);

        VkImageCreateInfo imageCI = vkinit::ImageCreateInfo(format, usage, m_extent);
		AllocatedImage image = Memory::CreateImage(m_renderContext.Allocator, imageCI, MEMORY_USAGE_GPU);
		m_imageArray.push_back(image);

		VkImageViewCreateInfo viewInfo = vkinit::ImageViewCreateInfo(format, image.Image, aspectFlags);
		VkImageView view;
		vkcheck(vkCreateImageView(m_renderContext.Device, &viewInfo, nullptr, &view));
		AddAttachment(view, true);
    }

    bool Framebuffer::Builder::Build(Framebuffer& framebuffer, VkRenderPass renderPass)
    {
        check(framebuffer.m_framebuffer == VK_NULL_HANDLE);
        check(framebuffer.m_imageArray.empty());
        check(framebuffer.m_attachmentViewArray.empty());
		VkFramebufferCreateInfo info
		{
			.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
			.pNext = nullptr,
			.renderPass = renderPass,
			.attachmentCount = (uint32_t)m_attachments.size(),
			.pAttachments = m_attachments.data(),
			.width = m_extent.width,
			.height = m_extent.height,
			.layers = 1
		};
		VkFramebuffer framebufferHandle;
		vkcheck(vkCreateFramebuffer(m_renderContext.Device, &info, nullptr, &framebufferHandle));

        framebuffer.m_imageArray = std::move(m_imageArray);
        framebuffer.m_attachmentViewArray = std::move(m_attachments);
        framebuffer.m_extent = m_extent;
        framebuffer.m_cleanFlags = m_cleanFlags;
        framebuffer.m_framebuffer = framebufferHandle;
		return true;
    }

    void Framebuffer::Builder::MarkToClean(uint32_t index)
    {
        check(index < sizeof(m_cleanFlags) * 8);
        m_cleanFlags |= BIT_N(index);
    }

    Framebuffer::~Framebuffer()
    {
        check(m_framebuffer == VK_NULL_HANDLE);
        check(m_imageArray.empty());
        check(m_attachmentViewArray.empty());
    }

    void Framebuffer::Destroy(const RenderContext& renderContext)
    {
        for (uint32_t i = 0; i < m_imageArray.size(); ++i)
        {
            Memory::DestroyImage(renderContext.Allocator, m_imageArray[i]);
        }
        m_imageArray.clear();
        for (uint32_t i = 0; i < m_attachmentViewArray.size(); ++i)
        {
            if (m_cleanFlags & BIT_N(i))
                vkDestroyImageView(renderContext.Device, m_attachmentViewArray[i], nullptr);
        }
        m_attachmentViewArray.clear();
        vkDestroyFramebuffer(renderContext.Device, m_framebuffer, nullptr);
        m_framebuffer = VK_NULL_HANDLE;
    }

    VkFramebuffer Framebuffer::GetFramebufferHandle() const
    {
        return m_framebuffer;
    }
}
