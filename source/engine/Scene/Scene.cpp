// Autogenerated code for Mist project
// Source file
#include "Scene.h"
#include "Core/Logger.h"
#include "Core/Debug.h"

#include "RenderSystem/RenderSystem.h"
#include "RenderSystem/TextureLoader.h"



#ifdef MIST_MEM_MANAGEMENT
// TODO: wtf windows declare these macros and project does not compile when MIST_MEM_MANAGEMENT is defined. WTF!?
#undef min
#undef max  
#endif // MIST_MEM_MANAGEMENT

#include <glm/gtx/transform.hpp>
#include <glm/gtx/quaternion.hpp>
#include <glm/gtx/euler_angles.hpp>
#include <glm/fwd.hpp>
#include "Render/Mesh.h"
#include "Utils/GenericUtils.h"
#include "Render/VulkanRenderEngine.h"
#include "Render/DebugRender.h"
#include <algorithm>
#include <imgui.h>

#define SCENE_LOAD_YAML
#ifdef SCENE_LOAD_YAML

#include <yaml-cpp/yaml.h>

#endif // SCENE_LOAD_YAML
#include <fstream>
#include "Core/SystemMemory.h"
#include "Utils/TimeUtils.h"
#include "Render/Model.h"
#include "Utils/FileSystem.h"
#include "Render/RendererBase.h"
#include "Render/RenderProcesses/ShadowMap.h"
#include "Render/CommandList.h"

//#define MIST_ENABLE_LOADER_LOG

#ifdef SCENE_LOAD_YAML
YAML::Emitter& operator<<(YAML::Emitter& e, const glm::vec3& v)
{
	e << YAML::Flow << YAML::BeginSeq << v.x << v.y << v.z << YAML::EndSeq;
	return e;
}

YAML::Emitter& operator<<(YAML::Emitter& e, const glm::vec4& v)
{
	e << YAML::Flow << YAML::BeginSeq << v.x << v.y << v.z << v.w << YAML::EndSeq;
	return e;
}

YAML::Emitter& operator<<(YAML::Emitter& e, const Mist::tAngles& a)
{
	e << YAML::Flow << YAML::BeginSeq << a.m_pitch << a.m_yaw << a.m_roll << YAML::EndSeq;
	return e;
}


namespace YAML
{
	template<>
	struct convert<glm::vec2>
	{
		static Node encode(const glm::vec2& rhs)
		{
			Node node;
			node.push_back(rhs.x);
			node.push_back(rhs.y);
			return node;
		}

		static bool decode(const Node& node, glm::vec2& rhs)
		{
			if (!node.IsSequence() || node.size() != 2)
				return false;

			rhs.x = node[0].as<float>();
			rhs.y = node[1].as<float>();
			return true;
		}
	};

	template<>
	struct convert<glm::vec3>
	{
		static Node encode(const glm::vec3& rhs)
		{
			Node node;
			node.push_back(rhs.x);
			node.push_back(rhs.y);
			node.push_back(rhs.z);
			return node;
		}

		static bool decode(const Node& node, glm::vec3& rhs)
		{
			if (!node.IsSequence() || node.size() != 3)
				return false;

			rhs.x = node[0].as<float>();
			rhs.y = node[1].as<float>();
			rhs.z = node[2].as<float>();
			return true;
		}
	};

	template<>
	struct convert<Mist::tAngles>
	{
		static Node encode(const Mist::tAngles& rhs)
		{
			Node node;
			node.push_back(rhs.m_pitch);
			node.push_back(rhs.m_yaw);
			node.push_back(rhs.m_roll);
			return node;
		}

		static bool decode(const Node& node, Mist::tAngles& rhs)
		{
			if (!node.IsSequence() || node.size() != 3)
				return false;

			rhs.m_pitch = node[0].as<float>();
			rhs.m_yaw = node[1].as<float>();
			rhs.m_roll = node[2].as<float>();
			return true;
		}
	};
}

#endif


namespace Mist
{
	const char* LightTypeToStr(ELightType e)
	{
		switch (e)
		{
		case ELightType::Point: return "Point";
		case ELightType::Directional: return "Directional";
		case ELightType::Spot: return "Spot";
		}
		check(false);
		return nullptr;
	}

	ELightType StrToLightType(const char* str)
	{
		if (!strcmp(str, "Point")) return ELightType::Point;
		if (!strcmp(str, "Spot")) return ELightType::Spot;
		if (!strcmp(str, "Directional")) return ELightType::Directional;
		check(false);
		return (ELightType)0xff;
	}

	void TransformComponentToMatrix(const TransformComponent* transforms, glm::mat4* matrices, uint32_t count)
	{
		for (uint32_t i = 0; i < count; ++i)
			matrices[i] = math::ToMat4(transforms[i].Position, transforms[i].Rotation, transforms[i].Scale);
	}

	template <uint32_t N>
	void GetResourceFileId(const char* file, const char* resname, char(&buff)[N])
	{
		sprintf_s(buff, "%s|%s", file, resname);
	}

	EnvironmentData::EnvironmentData() :
		AmbientColor(0.02f, 0.02f, 0.02f),
		ActiveSpotLightsCount(0),
		ViewPosition(0.f),
		ActiveLightsCount(0)
	{
		DirectionalLight.Color = { 0.01f, 0.01f, 0.1f };
		DirectionalLight.Position = { 0.f, 0.f, 1.f };
		DirectionalLight.ShadowMapIndex = -1;
		DirectionalLight.Compression = 0.5f;
		for (uint32_t i = 0; i < MaxLights; ++i)
		{
			Lights[i] = DirectionalLight;
			Lights[i].Radius = 50.f;
			SpotLights[i].Direction = { 1.f, 0.f, 0.f };
			SpotLights[i].Position = { 0.f, 0.f, 0.f };
			SpotLights[i].Color = { 1.f, 1.f, 1.f };
			SpotLights[i].CosCutoff.x = 1.f;
			SpotLights[i].CosCutoff.y = 1.f;
			SpotLights[i].ShadowMapIndex = -1;
		}
		ZeroMem(this, sizeof(*this));
		AmbientColor = { 0.02f, 0.02f, 0.02f };
	}

	Scene::Scene(IRenderEngine* engine) : m_engine(static_cast<VulkanRenderEngine*>(engine))
	{
		// Create root scene
		//CreateRenderObject(RenderObject::InvalidId);
	}

	Scene::~Scene()
	{}

	void Scene::Init()
	{
		m_globalTransforms.AllocateAndResize(globals::MaxRenderObjects);
		m_localTransforms.AllocateAndResize(globals::MaxRenderObjects);
		m_renderTransforms.AllocateAndResize(globals::MaxRenderObjects);
		m_transformComponents.AllocateAndResize(globals::MaxRenderObjects);
		m_materials.AllocateAndResize(globals::MaxMaterials);
		m_names.Allocate(globals::MaxRenderObjects);
		m_hierarchy.Allocate(globals::MaxRenderObjects);
		for (uint32_t i = 0; i < MaxNodeLevel; ++i)
			m_dirtyNodes[i].Allocate(globals::MaxRenderObjects);

		PushRenderPipeline(RenderFlags_Fixed);
		PushRenderPipeline(RenderFlags_ShadowMap);
		PushRenderPipeline(RenderFlags_Emissive);
	}

	void Scene::Destroy()
	{
#if 0
		if (m_engine->GetScene() == this)
			m_engine->SetScene(nullptr);
#endif // 0
		DestroyRenderLists();

		const RenderContext& renderContext = m_engine->GetContext();

		for (uint32_t i = 0; i < m_models.GetSize(); ++i)
			m_models[i].Destroy(renderContext);
		m_models.Clear();
		m_localTransforms.Delete();
		m_globalTransforms.Delete();
		m_hierarchy.Delete();
		m_names.Delete();
		m_materials.Delete();
		for (uint32_t i = 0; i < MaxNodeLevel; ++i)
			m_dirtyNodes[i].Delete();
	}

	void Scene::InitFrameData(const RenderContext& renderContext, RenderFrameContext& frameContext)
	{
#if 0
		frameContext.GlobalBuffer->AllocDynamicUniform(renderContext, "Material", sizeof(MaterialUniform), MIST_MAX_MATERIALS);
		VkDescriptorBufferInfo info = frameContext.GlobalBuffer->GenerateDescriptorBufferInfo("Material");
		DescriptorBuilder::Create(*renderContext.LayoutCache, *renderContext.DescAllocator)
			.BindBuffer(0, &info, 1, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_SHADER_STAGE_FRAGMENT_BIT)
			.Build(renderContext, m_materialSetArray[frameContext.FrameIndex]);
#endif // 0
		//frameContext.GlobalBuffer->AllocDynamicUniform(renderContext, "u_materials", sizeof(sMaterialRenderData), globals::MaxRenderObjects);
	}

	void Scene::Tick(float deltaTime)
	{
		check(m_cameraIndex <m_cameras.GetSize());
		CameraController& c = GetCamera();
		c.Tick(deltaTime);
		m_engine->UpdateSceneView(c.GetCamera().GetView(), c.GetCamera().GetProjection());
	}

	const CameraController& Scene::GetCamera() const
	{
		check(m_cameraIndex <m_cameras.GetSize());
		return m_cameras[m_cameraIndex];
	}

	CameraController& Scene::GetCamera()
	{
		check(m_cameraIndex <m_cameras.GetSize());
		return m_cameras[m_cameraIndex];
	}

	sRenderObject Scene::CreateRenderObject(sRenderObject parent)
	{
		// Generate new node in all basics structures
		sRenderObject node = m_hierarchy.GetSize();
		m_localTransforms[node] = glm::mat4(1.f);
		m_globalTransforms[node] = glm::mat4(1.f);
		m_transformComponents[node] = { .Position = glm::vec3(0.f), .Rotation = tAngles(0.f), .Scale = glm::vec3(1.f) };
		char buff[64];
		sprintf_s(buff, "RenderObject_%u", node.Id);
		m_names.Push(buff);
		m_hierarchy.Push({ .Parent = parent });

		// Connect siblings
		if (parent.IsValid())
		{
			check(parent.Id < m_hierarchy.GetSize());
			sRenderObject firstSibling = m_hierarchy[parent].Child;
			if (firstSibling.IsValid())
			{
				sRenderObject sibling;
				for (sibling = firstSibling; m_hierarchy[sibling].Sibling.IsValid(); sibling = m_hierarchy[sibling].Sibling);
				m_hierarchy[sibling].Sibling = node;
			}
			else
			{
				m_hierarchy[parent].Child = node;
			}
		}

		m_hierarchy[node].Level = parent.IsValid() ? m_hierarchy[parent].Level + 1 : 0;
		m_hierarchy[node].Child = index_invalid;
		m_hierarchy[node].Sibling = index_invalid;
		return node;
	}

	index_t Scene::LoadModel(const RenderContext& context, const char* filepath)
	{
		PROFILE_SCOPE_LOGF(LoadModel, "Load model (%s)", filepath);
		cModel* model = GetModel(filepath);
		if (!model)
		{
			m_models.Push();
			model = &m_models.GetBack();
			check(model->LoadModel(context, filepath));
		}
		check(model);
		return (index_t)(model-m_models.GetData());
	}

	index_t Scene::NewCamera()
	{
		index_t cameraIndex = m_cameras.GetSize();
		m_cameras.Push();
		return cameraIndex;
	}

	void Scene::SetCamera(sRenderObject r, const CameraComponent& cc)
	{
		check(IsValid(r));
		check(cc.CameraIndex < m_cameras.GetSize());
		m_cameraComponentMap[r] = cc;
		if (cc.Main)
			m_cameraIndex = cc.CameraIndex;
	}

	void Scene::LoadScene(const RenderContext& context, const char* filepath)
	{
		PROFILE_SCOPE_LOGF(LoadScene, "Load scene (%s)", filepath);

		m_sceneFile = filepath;

		cFile file;
		check(file.OpenText(filepath, cFile::FileMode_Read) == cFile::Result_Ok);
		uint32_t size = file.GetContentSize();
		check(size);
		char* content = _new char[size];
		uint32_t contentReaded = file.Read(content, size, sizeof(char), size);
		file.Close();
		check(contentReaded <= size);
		content[contentReaded == size ? size - 1 : contentReaded] = 0;

		YAML::Node root = YAML::Load(content);
		check(root);
		YAML::Node envNode = root["Environment"];
		check(envNode);
		m_ambientColor = envNode["Ambient"].as<glm::vec3>();
		char skyboxTextures[Skybox::COUNT][256];
		strcpy_s(skyboxTextures[Skybox::FRONT], envNode["Skybox"]["Front"].as<std::string>().c_str());
		strcpy_s(skyboxTextures[Skybox::BACK], envNode["Skybox"]["Back"].as<std::string>().c_str());
		strcpy_s(skyboxTextures[Skybox::TOP], envNode["Skybox"]["Top"].as<std::string>().c_str());
		strcpy_s(skyboxTextures[Skybox::BOTTOM], envNode["Skybox"]["Bottom"].as<std::string>().c_str());
		strcpy_s(skyboxTextures[Skybox::LEFT], envNode["Skybox"]["Left"].as<std::string>().c_str());
		strcpy_s(skyboxTextures[Skybox::RIGHT], envNode["Skybox"]["Right"].as<std::string>().c_str());
		LoadSkybox(m_engine->GetContext(), m_skybox,
			skyboxTextures[Skybox::FRONT],
			skyboxTextures[Skybox::BACK],
			skyboxTextures[Skybox::LEFT],
			skyboxTextures[Skybox::RIGHT],
			skyboxTextures[Skybox::TOP],
			skyboxTextures[Skybox::BOTTOM]);



		YAML::Node renderObjectSeq = root["RenderObjects"];
		check(renderObjectSeq);
		for (const auto& it : renderObjectSeq)
		{
			uint32_t parent = it["Parent"].as<uint32_t>();
			sRenderObject rb = CreateRenderObject(parent);
			SetRenderObjectName(rb, it["Name"].as<std::string>().c_str());

			TransformComponent t;
			YAML::Node transformNode = it["TransformComponent"];
			t.Position = transformNode["Position"].as<glm::vec3>();
			t.Rotation = transformNode["Rotation"].as<tAngles>();
			t.Scale = transformNode["Scale"].as<glm::vec3>();
			SetTransform(rb, t);

			YAML::Node lightNode = it["LightComponent"];
			if (lightNode)
			{
				LightComponent lightComponent;
				lightComponent.Color = lightNode["Color"].as<glm::vec3>();
				lightComponent.Radius = lightNode["Radius"].as<float>();
				lightComponent.Compression = lightNode["Compression"].as<float>();
				lightComponent.OuterCutoff = lightNode["OuterCutoff"].as<float>();
				lightComponent.Cutoff = lightNode["Cutoff"].as<float>();
				lightComponent.ProjectShadows = lightNode["ProjectShadows"].as<bool>();
				lightComponent.Type = StrToLightType(lightNode["Type"].as<std::string>().c_str());
				SetLight(rb, lightComponent);
			}

			YAML::Node meshNode = it["MeshComponent"];
			if (meshNode)
			{
				MeshComponent m;
				strcpy_s(m.MeshAssetPath, meshNode["MeshAssetPath"].as<std::string>().c_str());
				m.MeshIndex = LoadModel(context, m.MeshAssetPath);
				SetMesh(rb, m);
			}

			YAML::Node cameraNode = it["CameraComponent"];
			if (cameraNode)
			{
				CameraComponent cc = { NewCamera() };
				cc.Main = cameraNode["Main"].as<bool>();
				SetCamera(rb, cc);
			}
		}

		if (m_cameraIndex == index_invalid)
		{
			logwarn("Scene without main camara enabled. Creating one by default.\n");
			sRenderObject rb = CreateRenderObject(GetRoot());
			SetRenderObjectName(rb, "DefaultMainCamera");
			CameraComponent cc = { NewCamera() };
			cc.Main = true;
			SetCamera(rb, cc);
		}
		delete[] content;
	}

	void Scene::SaveScene(const RenderContext& context, const char* filepath)
	{
		YAML::Emitter emitter;

		emitter << YAML::BeginMap;
		emitter << YAML::Key << "Environment";
		{
			emitter << YAML::BeginMap;
			emitter << YAML::Key << "Ambient" << YAML::Value << m_ambientColor;
			emitter << YAML::Key << "Skybox" << YAML::BeginMap;
			emitter << YAML::Key << "Front" << YAML::Value << m_skybox.CubemapFiles[Skybox::FRONT];
			emitter << YAML::Key << "Back" << YAML::Value << m_skybox.CubemapFiles[Skybox::BACK];
			emitter << YAML::Key << "Top" << YAML::Value << m_skybox.CubemapFiles[Skybox::TOP];
			emitter << YAML::Key << "Bottom" << YAML::Value << m_skybox.CubemapFiles[Skybox::BOTTOM];
			emitter << YAML::Key << "Left" << YAML::Value << m_skybox.CubemapFiles[Skybox::LEFT];
			emitter << YAML::Key << "Right" << YAML::Value << m_skybox.CubemapFiles[Skybox::RIGHT];
			emitter << YAML::EndMap;
			emitter << YAML::EndMap;
		}
		emitter << YAML::Key << "RenderObjects";
		emitter << YAML::BeginSeq;
		for (uint32_t i = 0; i < GetRenderObjectCount(); ++i)
		{
			const Hierarchy& h = m_hierarchy[i];
			emitter << YAML::BeginMap;
			emitter << YAML::Key << "RenderObject" << YAML::Value << i;
			emitter << YAML::Key << "Name" << YAML::Value << GetRenderObjectName(i);
			emitter << YAML::Key << "Parent" << YAML::Value << h.Parent;

			const TransformComponent& t = m_transformComponents[i];
			emitter << YAML::Key << "TransformComponent" << YAML::BeginMap;
			emitter << YAML::Key << "Position" << YAML::Value << t.Position;
			emitter << YAML::Key << "Rotation" << YAML::Value << t.Rotation;
			emitter << YAML::Key << "Scale" << YAML::Value << t.Scale;
			emitter << YAML::EndMap;

			if (m_lightComponentMap.contains(i))
			{
				const LightComponent& light = m_lightComponentMap[i];
				emitter << YAML::Key << "LightComponent" << YAML::BeginMap;
				emitter << YAML::Key << "Type" << YAML::Value << LightTypeToStr(light.Type);
				emitter << YAML::Key << "Color" << YAML::Value << light.Color;
				emitter << YAML::Key << "Radius" << YAML::Value << light.Radius;
				emitter << YAML::Key << "Compression" << YAML::Value << light.Radius;
				emitter << YAML::Key << "OuterCutoff" << YAML::Value << light.OuterCutoff;
				emitter << YAML::Key << "Cutoff" << YAML::Value << light.Cutoff;
				emitter << YAML::Key << "ProjectShadows" << YAML::Value << light.ProjectShadows;
				emitter << YAML::EndMap;
			}

			if (m_meshComponentMap.contains(i))
			{
				emitter << YAML::Key << "MeshComponent" << YAML::BeginMap;
				const MeshComponent& mesh = m_meshComponentMap[i];
				emitter << YAML::Key << "MeshAssetPath" << YAML::Value << mesh.MeshAssetPath;
				emitter << YAML::EndMap;
			}

			if (m_cameraComponentMap.contains(i))
			{
				const CameraComponent& cc = m_cameraComponentMap.at(i);
				emitter << YAML::Key << "CameraComponent" << YAML::BeginMap;
				emitter << YAML::Key << "Main" << YAML::Value << cc.Main;
				emitter << YAML::EndMap;
			}

			emitter << YAML::EndMap;
		}
		emitter << YAML::EndSeq;
		emitter << YAML::EndMap;

		check(emitter.good());
		const char* out = emitter.c_str();
		uint32_t size = (uint32_t)emitter.size();
		//logfinfo("YAML %u b\n%s\n", size, out);
		cFile file;
		check(file.OpenText(filepath, cFile::FileMode_Write) == cFile::Result_Ok);
		file.Write(out, size);
		file.Close();

		logfok("--- Scene file saved in: %s (%d bytes) ---\n", filepath, size);
	}

	void Scene::DestroyRenderObject(sRenderObject object)
	{
		check(false && "not implemented yet" && __FUNCTION__ && __FILE__ && __LINE__);
	}

	const MeshComponent* Scene::GetMesh(sRenderObject renderObject) const
	{
		check(IsValid(renderObject));
		const MeshComponent* mesh = nullptr;
		if (m_meshComponentMap.contains(renderObject))
			mesh = &m_meshComponentMap.at(renderObject);
		return mesh;
	}

	void Scene::SetMesh(sRenderObject renderObject, const MeshComponent& meshComponent)
	{
		check(IsValid(renderObject));
		m_meshComponentMap[renderObject] = meshComponent;
	}

	const char* Scene::GetRenderObjectName(sRenderObject object) const
	{
		return IsValid(object) ? m_names[object.Id].c_str() : nullptr;
	}

	bool Scene::IsValid(sRenderObject object) const
	{
		return object.Id < GetRenderObjectCount();
	}

	uint32_t Scene::GetRenderObjectCount() const
	{
		return m_hierarchy.GetSize();
	}

	sRenderObject Scene::GetRoot() const
	{
		static sRenderObject root = 0;
		//for (; m_hierarchy[root].Parent.IsValid(); root = m_hierarchy[root].Parent);
		return root;
	}

	void Scene::SetRenderObjectName(sRenderObject renderObject, const char* name)
	{
		check(IsValid(renderObject));
		m_names[renderObject] = name;
	}

	const TransformComponent& Scene::GetTransform(sRenderObject renderObject) const
	{
		check(IsValid(renderObject));
		return m_transformComponents[renderObject];
	}

	void Scene::SetTransform(sRenderObject renderObject, const TransformComponent& transform)
	{
		check(IsValid(renderObject));
		m_transformComponents[renderObject] = transform;
		MarkAsDirty(renderObject);
	}

	const LightComponent* Scene::GetLight(sRenderObject renderObject) const
	{
		check(IsValid(renderObject));
		const LightComponent* light = nullptr;
		if (m_lightComponentMap.contains(renderObject))
			light = &m_lightComponentMap.at(renderObject);
		return light;
	}

	void Scene::SetLight(sRenderObject renderObject, const LightComponent& light)
	{
		check(IsValid(renderObject));
		m_lightComponentMap[renderObject] = light;
	}

	void Scene::MarkAsDirty(sRenderObject renderObject)
	{
		check(IsValid(renderObject));
		int32_t level = m_hierarchy[renderObject].Level;
		m_dirtyNodes[level].Push(renderObject);
		for (sRenderObject child = m_hierarchy[renderObject].Child; child.IsValid(); child = m_hierarchy[child].Sibling)
			MarkAsDirty(child);
	}


	void Scene::RecalculateTransforms()
	{
		CPU_PROFILE_SCOPE(RecalculateTransforms);
		check(m_localTransforms.GetSize() == m_transformComponents.GetSize());
		check(m_globalTransforms.GetSize() == m_transformComponents.GetSize());
		TransformComponentToMatrix(m_transformComponents.GetData(), m_localTransforms.GetData(), m_transformComponents.GetSize());
		// Process root level first
		if (!m_dirtyNodes[0].IsEmpty())
		{
			for (uint32_t i = 0; i < m_dirtyNodes[0].GetSize(); ++i)
			{
				uint32_t nodeIndex = m_dirtyNodes[0][i];
				m_globalTransforms[nodeIndex] = m_localTransforms[nodeIndex];
			}
			m_dirtyNodes[0].Clear();
		}
		// Iterate over the deeper levels
		for (uint32_t level = 1; level < MaxNodeLevel; ++level)
		{
			for (uint32_t nodeIndex = 0; nodeIndex < m_dirtyNodes[level].GetSize(); ++nodeIndex)
			{
				int32_t node = m_dirtyNodes[level][nodeIndex];
				int32_t parentNode = m_hierarchy[node].Parent;
				m_globalTransforms[node] = m_globalTransforms[parentNode] * m_localTransforms[node];
			}
			m_dirtyNodes[level].Clear();
		}

		index_t offset = 0;
		for (index_t i = 0; i < m_hierarchy.GetSize(); ++i)
		{
			if (m_meshComponentMap.contains(i))
			{
				index_t meshIndex = m_meshComponentMap[i].MeshIndex;
				cModel& model = m_models[meshIndex];
				uint32_t count = model.GetTransformsCount();
				check(offset + count < m_renderTransforms.GetSize());
				model.UpdateRenderTransforms(m_renderTransforms.GetData() + offset, m_globalTransforms[i]);
				offset += count;
			}
		}

	}

	bool Scene::LoadSkybox(const RenderContext& context, Skybox& skybox, const char* front, const char* back, const char* left, const char* right, const char* top, const char* bottom)
	{
		PROFILE_SCOPE_LOG(LoadSkybox, "LoadSkybox");

#ifdef RENDER_BACKEND_TEST
		//return true;
#endif

		// descriptors generator
		DescriptorBuilder builder = DescriptorBuilder::Create(*context.LayoutCache, *context.DescAllocator);

		strcpy_s(skybox.CubemapFiles[Skybox::FRONT], front);
		strcpy_s(skybox.CubemapFiles[Skybox::BACK], back);
		strcpy_s(skybox.CubemapFiles[Skybox::LEFT], left);
		strcpy_s(skybox.CubemapFiles[Skybox::RIGHT], right);
		strcpy_s(skybox.CubemapFiles[Skybox::TOP], top);
		strcpy_s(skybox.CubemapFiles[Skybox::BOTTOM], bottom);

		// Load textures from files
		rendersystem::textureloader::TextureData textureData[Skybox::COUNT];
		const uint8_t* pixelsArray[Skybox::COUNT];
		for (uint32_t i = 0; i < Skybox::COUNT; ++i)
		{
			check(rendersystem::textureloader::LoadTextureData_u8(&textureData[i], skybox.CubemapFiles[i]));
			pixelsArray[i] = textureData[i].u8data;
			if (i)
				check(textureData[i - 1].width == textureData[i].width &&
					textureData[i - 1].height == textureData[i].height &&
					textureData[i - 1].channels == textureData[i].channels);
		}
		uint64_t textureSize = textureData[0].width * textureData[0].height * sizeof(uint8_t) * textureData[0].channels;

		render::TextureDescription texDesc;
		texDesc.extent = { textureData[0].width, textureData[0].height, 1 };
		texDesc.format = render::Format_R8G8B8A8_UNorm;
		texDesc.layers = Skybox::COUNT;
		texDesc.dimension = render::ImageDimension_Cube;
		texDesc.debugName = "cubemap";
		skybox.texture = g_device->CreateTexture(texDesc);

		render::utils::UploadContext upload(g_device);
		for (uint32_t i = 0; i < Skybox::COUNT; ++i)
		{
			upload.WriteTexture(skybox.texture, 0, i, pixelsArray[i], textureSize);
			upload.SetTextureLayout(skybox.texture, render::ImageLayout_ShaderReadOnly, i);
		}
		upload.Submit();
		return true;
	}

	cModel* Scene::GetModel(const char* modelName)
	{
		for (uint32_t i = 0; i < m_models.GetSize(); ++i)
		{
			if (!strcmp(m_models[i].GetName(), modelName))
				return &m_models[i];
		}
		return nullptr;
	}

	void Scene::Draw(const RenderContext& context, ShaderProgram* shader, uint32_t materialSetIndex, uint32_t modelSetIndex, VkDescriptorSet modelSet, uint16_t renderFlags) const
	{
		CPU_PROFILE_SCOPE(Scene_Draw);
		CommandList* commandList = context.CmdList;

		// Iterate scene graph to render models.
		const cMaterial* lastMaterial = nullptr;
		const cMesh* lastMesh = nullptr;
		uint32_t nodeCount = GetRenderObjectCount();
		index_t renderTransformOffset = 0;
		index_t materialOffset = 0;
		for (uint32_t i = 0; i < nodeCount; ++i)
		{
			sRenderObject renderObject = i;
			const MeshComponent* meshComponent = GetMesh(renderObject);
			if (meshComponent)
			{
				check(meshComponent->MeshIndex != index_invalid);
				const cModel& model = m_models[meshComponent->MeshIndex];

				// BaseOffset in buffer is already setted when descriptor was created.
				for (index_t j = 0; j < model.m_meshes.GetSize(); ++j)
				{
					//shader->SetDynamicBufferOffset(context, "u_model", sizeof(glm::mat4), renderTransformOffset);

					const cMesh& mesh = model.m_meshes[j];
					//commandList->BindVertexBuffer(mesh.VertexBuffer);
                    //commandList->BindIndexBuffer(mesh.IndexBuffer);
					g_render->SetVertexBuffer(mesh.vb);
					g_render->SetIndexBuffer(mesh.ib);
					glm::mat4 m(1.f);
					g_render->SetShaderProperty("u_model", &m, sizeof(m));

					for (index_t k = 0; k < mesh.primitiveArray.GetSize(); ++k)
					{
						const PrimitiveMeshData& primitive = mesh.primitiveArray[k];
						if (primitive.RenderFlags & renderFlags)
						{
							if (!(renderFlags & RenderFlags_NoTextures))
							{
								check(primitive.Material);
								index_t offset = limits_cast<index_t>(primitive.Material - model.m_materials.GetData());
								check(materialOffset + offset < m_materials.GetSize());
								primitive.Material->BindTextures(materialSetIndex);
								sMaterialRenderData materialData = primitive.Material->GetRenderData();
								g_render->SetShaderProperty("u_material", &materialData, sizeof(materialData));
								//shader->SetDynamicBufferOffset(context, "u_material", sizeof(sMaterialRenderData), materialOffset + (index_t)offset);
							}
							//commandList->BindProgramDescriptorSets();
							//commandList->DrawIndexed(primitive.Count, 1, primitive.FirstIndex, 0);
							g_render->DrawIndexed(primitive.Count, 1, primitive.FirstIndex);
						}
					}
					++renderTransformOffset;
				}
				materialOffset += model.GetMaterialCount();
				check(materialOffset < m_materials.GetSize());
			}
		}
	}

	void Scene::DrawWithMaterials(const RenderContext& context, const tViewRenderInfo& viewRenderInfo, uint32_t textureSlot) const
	{
		CPU_PROFILE_SCOPE(Scene_DrawWithMaterials);
		CommandList* commandList = context.CmdList;

		const cMaterial* currentMaterial = nullptr;
		rendersystem::ShaderProgram* currentShader = nullptr;
		index_t currentTransformOffset = index_invalid;

		// Iterate scene graph to render models.
		uint32_t nodeCount = GetRenderObjectCount();
		index_t renderTransformOffset = 0;
		index_t materialOffset = 0;
		for (uint32_t i = 0; i < nodeCount; ++i)
		{
			sRenderObject renderObject = i;
			const MeshComponent* meshComponent = GetMesh(renderObject);
			if (meshComponent)
			{
				check(meshComponent->MeshIndex != index_invalid);
				const cModel& model = m_models[meshComponent->MeshIndex];

				// BaseOffset in buffer is already setted when descriptor was created.
				for (index_t j = 0; j < model.m_meshes.GetSize(); ++j)
				{
					const cMesh& mesh = model.m_meshes[j];
                    //commandList->BindVertexBuffer(mesh.VertexBuffer);
                    //commandList->BindIndexBuffer(mesh.IndexBuffer);
					g_render->SetVertexBuffer(mesh.vb);
					g_render->SetIndexBuffer(mesh.ib);
                    glm::mat4 m(1.f);
                    g_render->SetShaderProperty("u_model", &m, sizeof(m));

					for (index_t k = 0; k < mesh.primitiveArray.GetSize(); ++k)
					{
						const PrimitiveMeshData& primitive = mesh.primitiveArray[k];
						const cMaterial* mat = primitive.Material;
						check(mat && mat->m_shader);
						if (primitive.RenderFlags & viewRenderInfo.flags)
						{
#if 0
							ShaderProgram* shader = mat->m_shader;
							if (!(viewRenderInfo.flags & RenderFlags_NoTextures) && mat != currentMaterial)
							{
								currentMaterial = mat;
								if (shader != currentShader)
								{
									GraphicsState state = commandList->GetGraphicsState();
									state.Program = shader;
									commandList->SetGraphicsState(state);
									shader->SetBufferData(context, "u_Camera", &viewRenderInfo.view, sizeof(CameraData));
									shader->SetBufferData(context, "u_depthInfo", &viewRenderInfo.shadowMap, sizeof(tShadowMapData));
									shader->SetBufferData(context, "u_env", &viewRenderInfo.environment, sizeof(EnvironmentData));
									shader->BindSampledTextureArray(context, "u_ShadowMap", viewRenderInfo.shadowMapTextures, CountOf(viewRenderInfo.shadowMapTextures));
									shader->BindSampledTexture(context, "u_cubemap", *viewRenderInfo.cubemap);
									currentShader = shader;
								}
								currentMaterial->BindTextures(context, *shader, textureSlot);
								index_t offset = limits_cast<index_t>(mat - model.m_materials.GetData());
								check(materialOffset + offset < m_materials.GetSize());
								shader->SetDynamicBufferOffset(context, "u_material", sizeof(sMaterialRenderData), materialOffset + offset);
							}

							if (currentTransformOffset != renderTransformOffset)
							{
								shader->SetDynamicBufferOffset(context, "u_model", sizeof(glm::mat4), renderTransformOffset);
								currentTransformOffset = renderTransformOffset;
							}
							commandList->BindProgramDescriptorSets();
							commandList->DrawIndexed(primitive.Count, 1, primitive.FirstIndex, 0);
#else
                            rendersystem::ShaderProgram* shader = mat->m_shaderProgram;
                            if (!(viewRenderInfo.flags & RenderFlags_NoTextures) && mat != currentMaterial)
                            {
                                currentMaterial = mat;
                                if (shader != currentShader)
                                {
									g_render->SetShader(shader);
									g_render->SetShaderProperty("u_Camera", &viewRenderInfo.view, sizeof(CameraData));
                                    g_render->SetShaderProperty("u_depthInfo", &viewRenderInfo.shadowMap, sizeof(tShadowMapData));
                                    g_render->SetShaderProperty("u_env", &viewRenderInfo.environment, sizeof(EnvironmentData));
									g_render->SetTextureSlot("u_ShadowMap", viewRenderInfo.shadowMapTextures, Mist::CountOf(viewRenderInfo.shadowMapTextures));
									g_render->SetTextureSlot("u_cubemap", viewRenderInfo.cubemapTex);
                                    currentShader = shader;
                                }
                                currentMaterial->BindTextures(textureSlot);
                                index_t offset = limits_cast<index_t>(mat - model.m_materials.GetData());
                                check(materialOffset + offset < m_materials.GetSize());
                                //shader->SetDynamicBufferOffset(context, "u_material", sizeof(sMaterialRenderData), materialOffset + offset);
								sMaterialRenderData mrd = currentMaterial->GetRenderData();
								g_render->SetShaderProperty("u_material", &mrd, sizeof(mrd));
                            }

                            if (currentTransformOffset != renderTransformOffset)
                            {
                                glm::mat4 m(1.f);
                                g_render->SetShaderProperty("u_model", &m, sizeof(m));
                                currentTransformOffset = renderTransformOffset;
                            }
							g_render->DrawIndexed(primitive.Count, 1, primitive.FirstIndex);
#endif // 0

						}
					}
					++renderTransformOffset;
				}
				materialOffset += model.GetMaterialCount();
				check(materialOffset < m_materials.GetSize());
				//++renderTransformOffset;
			}
		}
	}

	render::TextureHandle Scene::GetSkyboxTexture() const
	{
		return m_skybox.texture;
	}

	void Scene::ImGuiDraw()
	{
		ImGui::Begin("SceneGraph");

		float posStep = 0.5f;
		float rotStep = 0.1f;
		float sclStep = 0.5f;

		char tempSceneFile[256];
		strcpy_s(tempSceneFile, m_sceneFile.GetAssetPath());

		const RenderContext& context = m_engine->GetContext();
		ImGui::Columns(3);
		if (ImGui::Button("Save"))
			SaveScene(context, tempSceneFile);
		ImGui::NextColumn();
		if (ImGui::Button("Load"))
			LoadScene(context, tempSceneFile);
		ImGui::NextColumn();
		if (ImGui::InputText("Scene file", tempSceneFile, 256))
			m_sceneFile = tempSceneFile;
		ImGui::Columns();

		ImGui::Separator();
		ImGui::Text("Environment");
		ImGui::ColorEdit3("Ambient color", &m_ambientColor[0]);
		ImGui::Button("Reload");

		ImGui::Separator();
		if (ImGui::TreeNode("Scene tree"))
		{
			for (uint32_t i = 0; i < GetRenderObjectCount(); ++i)
			{
				char treeId[2];
				sprintf_s(treeId, "%u", i);
				if (ImGui::TreeNode(treeId, "%s", GetRenderObjectName(i)))
				{
					glm::mat4 transform;
					TransformComponentToMatrix(&m_transformComponents[i], &transform, 1);
					DebugRender::DrawAxis(transform);
					const Hierarchy& node = m_hierarchy[i];
					ImGui::Text("Parent: %s", node.Parent != UINT32_MAX ? GetRenderObjectName(node.Parent) : "None");
					char buff[32];
					sprintf_s(buff, "##TransformComponent%u", i);
					if (ImGui::TreeNode(buff, "Transform component"))
					{
						TransformComponent& t = m_transformComponents[i];
						ImGui::Columns(2);
						ImGui::Text("Position");
						ImGui::NextColumn();
						sprintf_s(buff, "##TransformPos%d", i);
						bool dirty = ImGui::DragFloat3(buff, &t.Position[0], posStep);
						ImGui::NextColumn();
						sprintf_s(buff, "TransformRot%d", i);
						dirty |= ImGuiUtils::EditAngles(buff, "Rotation", t.Rotation);
						ImGui::NextColumn();
						ImGui::Text("Scale");
						ImGui::NextColumn();
						sprintf_s(buff, "##TransformScl%d", i);
						dirty |= ImGui::DragFloat3(buff, &t.Scale[0], sclStep);
						ImGui::Columns();
						ImGui::TreePop();

						if (dirty)
							MarkAsDirty(i);
					}
					sprintf_s(buff, "##LightComponent%u", i);
					if (m_lightComponentMap.contains(i))
					{
						if (ImGui::TreeNode(buff, "Light component"))
						{
							LightComponent& light = m_lightComponentMap[i];
							static const char* lightTypes[] = { "Point", "Directional", "Spot" };
							uint32_t lightCount = sizeof(lightTypes) / sizeof(const char*);
							if (ImGui::BeginCombo("Type", lightTypes[(uint32_t)light.Type]))
							{
								for (uint32_t j = 0; j < lightCount; ++j)
								{
									if (ImGui::Selectable(lightTypes[j], j == (uint32_t)light.Type))
										light.Type = (ELightType)j;
								}
								ImGui::EndCombo();
							}
							ImGui::Columns(2);
							ImGui::Text("Color");
							ImGui::NextColumn();
							sprintf_s(buff, "##LightColor%u", i);
							ImGui::ColorEdit3(buff, &light.Color[0]);
							ImGui::NextColumn();
							ImGui::Text("Radius");
							ImGui::NextColumn();
							sprintf_s(buff, "##LightRadius%u", i);
							ImGui::DragFloat(buff, &light.Radius, 0.5f, 0.f, FLT_MAX);
							ImGui::NextColumn();
							ImGui::Text("Compression");
							sprintf_s(buff, "##LightCompression%u", i);
							ImGui::NextColumn();
							ImGui::DragFloat(buff, &light.Compression, 0.05f, 0.f, FLT_MAX);
							ImGui::NextColumn();
							ImGui::Text("Outer cutoff");
							ImGui::NextColumn();
							sprintf_s(buff, "##LightOuterCutoff%u", i);
							ImGui::DragFloat(buff, &light.OuterCutoff, 0.1f, 0.f, FLT_MAX);
							ImGui::NextColumn();
							ImGui::Text("Cutoff");
							ImGui::NextColumn();
							sprintf_s(buff, "##LightCutoff%u", i);
							ImGui::DragFloat(buff, &light.Cutoff, 0.1f, 0.f, FLT_MAX);
							ImGui::NextColumn();
							ImGui::Text("Project shadows");
							ImGui::NextColumn();
							sprintf_s(buff, "##LightShadows%u", i);
							ImGui::Checkbox(buff, &light.ProjectShadows);
							ImGui::NextColumn();

							ImGui::Columns();
							ImGui::TreePop();
						}
					}
					if (m_meshComponentMap.contains(i))
					{
						sprintf_s(buff, "##MeshComponent%u", i);
						if (ImGui::TreeNode(buff, "Mesh component"))
						{
							const MeshComponent& meshComp = m_meshComponentMap.at(i);
							ImGui::Text("Model: [%u] %s", meshComp.MeshIndex, meshComp.MeshAssetPath);
							ImGui::Text("Model name: %s", m_models[meshComp.MeshIndex].GetName());
							ImGui::TreePop();
						}
					}

					ImGui::TreePop();
				}
			}
			ImGui::TreePop();
		}
		if (ImGui::TreeNode("Model list"))
		{
			ImGui::Columns(2);
			char buff[32];
			for (index_t i = 0; i < m_models.GetSize(); ++i)
			{
				ImGui::Text("Model: %s", m_models[i].GetName());
				ImGui::NextColumn();
				sprintf_s(buff, "##modelbutton_%d", i);
				ImGui::PushID(buff);
				if (ImGui::Button("..."))
				{ 
					logfinfo("editing model %s\n", m_models[i].GetName());
					m_editingModel = i;
				}
				ImGui::PopID();
				ImGui::NextColumn();
			}
			ImGui::Columns();
			ImGui::TreePop();
		}
		if (m_editingModel != index_invalid)
		{
			ImGui::PushStyleColor(ImGuiCol_ChildBg, ImGui::GetStyleColorVec4(ImGuiCol_FrameBg));
			if (ImGui::BeginChild("EditingModelChild", ImVec2(-FLT_MIN, ImGui::GetTextLineHeightWithSpacing() * 8), ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeY))
			{
				ImGui::Text("Editing model %s", m_models[m_editingModel].GetName());
				ImGui::Separator();
				m_models[m_editingModel].ImGuiDraw();
			}
			ImGui::PopStyleColor();
			ImGui::EndChild();
		}
		if (ImGui::TreeNode("Render transforms"))
		{
			for (uint32_t i = 0; i < m_renderTransforms.GetSize(); ++i)
			{
				ImGui::Text("%3d", i);
				for (uint32_t row = 0; row < 4; ++row)
					ImGui::Text("%6.3f, %6.3f, %6.3f, %6.3f", m_renderTransforms[i][0][row], m_renderTransforms[i][1][row], m_renderTransforms[i][2][row], m_renderTransforms[i][3][row]);
			}
			ImGui::TreePop();
		}
		if (ImGui::TreeNode("Render passes"))
		{
			for (uint32_t i = 0; i < m_drawListArray.GetSize(); ++i)
			{
				const tDrawList& list = m_drawListArray[i];
				ImGui::Text("Render flags: %4d | Render items: %4d/%4d", list.RenderFlags, list.Items.GetSize(), list.Items.GetReservedSize());
			}
			ImGui::TreePop();
		}
		ImGui::End();
	}

	bool Scene::IsDirty() const
	{
		for (uint32_t i = 0; i < MaxNodeLevel; ++i)
		{
			if (!m_dirtyNodes[i].IsEmpty())
				return true;
		}
		return false;
	}

	void Scene::InitRenderPass()
	{
		if (m_drawListArray.IsEmpty())
			return;
		ClearDrawLists();

		index_t transformGlobalIndex = 0;
		index_t materialGlobalIndex = 0;
		for (index_t i = 0; i < GetRenderObjectCount(); ++i)
		{
			if (m_meshComponentMap.contains(i))
			{
				index_t meshIndex = m_meshComponentMap[i].MeshIndex;
				const cModel& model = m_models[meshIndex];
				for (index_t j = 0; j < model.m_nodes.GetSize(); ++j)
				{
					if (model.m_nodes[j].MeshId != index_invalid)
					{
						const cMesh& mesh = model.m_meshes[model.m_nodes[j].MeshId];
						for (index_t k = 0; k < mesh.primitiveArray.GetSize(); ++k)
						{
							for (index_t m = 0; m < m_drawListArray.GetSize(); ++m)
							{
								index_t materialIndex = mesh.primitiveArray[k].Material - model.m_materials.GetData();

								// the transform index match with the node index inside model node graph
								m_drawListArray[m].SubmitRenderPrimitive(&mesh, k, transformGlobalIndex + j, materialIndex + materialGlobalIndex);
							}
						}
					}
				}
				transformGlobalIndex += model.GetTransformsCount();
				materialGlobalIndex += model.GetMaterialCount();
				check(materialGlobalIndex < m_materials.GetSize() && transformGlobalIndex < m_renderTransforms.GetSize());
			}
		}
	}

	void Scene::PushRenderPipeline(uint32_t pipelineFlags)
	{
		m_drawListArray.Push();
		m_drawListArray.GetBack().RenderFlags = pipelineFlags;
		m_drawListArray.GetBack().Items.Allocate(1600);
	}

	const tDrawList* Scene::FindRenderPipeline(uint32_t pipelineFlags) const
	{
		for (index_t i = 0; i < m_drawListArray.GetSize(); ++i)
		{
			if (m_drawListArray[i].RenderFlags == pipelineFlags)
				return &m_drawListArray[i];
		}
		return nullptr;
	}

	void Scene::DestroyRenderLists()
	{
		for (index_t i = 0; i < m_drawListArray.GetSize(); ++i)
		{
			m_drawListArray[i].Items.Delete();
			m_drawListArray[i].RenderFlags = 0;
		}
		m_drawListArray.Clear();
	}

	void Scene::ClearDrawLists()
	{
		for (uint32_t i = 0; i < m_drawListArray.GetSize(); ++i)
		{
			tDrawList& list = m_drawListArray[i];
			//list.RenderFlags = 0;
			list.Items.Clear();
		}
		//m_drawListArray.Clear();
	}

	void Scene::RenderPipelineDraw(const RenderContext& context, uint32_t pipelineFlags, index_t materialSetIndex, rendersystem::ShaderProgram* program)
	{
		CPU_PROFILE_SCOPE(RenderPipelineDraw);
		const tDrawList* drawList = FindRenderPipeline(pipelineFlags);
		if (!drawList)
			return;

		
		const RenderFrameContext& frameContext = context.GetFrameContext();
		const CameraData& cameraData = *GetCameraData();
		const Renderer* renderer = context.Renderer;
		const ShadowMapProcess* shadowMapping = (ShadowMapProcess*)renderer->GetRenderProcess(RENDERPROCESS_SHADOWMAP);

        const uint32_t shadowMapTexturesSlot = 2;
		tShadowMapData depthViewInfo;
		const cTexture* shadowMapTextures[globals::MaxShadowMapAttachments];
        //for (uint32_t i = 0; i < globals::MaxShadowMapAttachments; ++i)
        //{
        //    // Shadow map matrices from shadow map process
        //    depthViewInfo.LightViewMatrices[i] = shadowMapping->m_shadowMapPipeline.GetLightVP(i);
        //    // Shadow map textures from shadow map process
        //    shadowMapTextures[i] = shadowMapping->GetRenderTarget(i)->GetDepthTexture();
        //}

		const cMesh* mesh = nullptr;
		const cMaterial* material = nullptr;
		rendersystem::ShaderProgram* shader = program;

		if (shader)
			g_render->SetShader(shader);

		for (index_t i = 0; i < drawList->Items.GetSize(); ++i)
		{
			const tDrawListItem& data = drawList->Items[i];
			check(data.Mesh && data.PrimitiveIndex < data.Mesh->primitiveArray.GetSize() && data.TransformIndex != index_invalid);
			if (data.Mesh != mesh)
			{
				mesh = data.Mesh;
				g_render->SetVertexBuffer(mesh->vb);
				g_render->SetIndexBuffer(mesh->ib);
			}

			const PrimitiveMeshData& primitive = mesh->primitiveArray[data.PrimitiveIndex];
			check(primitive.Count && primitive.Material);
			if (material != primitive.Material)
			{
                material = primitive.Material;
				check(program || material->m_shaderProgram);
                if (!program && shader != material->m_shaderProgram)
                {
					g_render->SetShader(shader);
					g_render->SetShaderProperty("u_camera", &cameraData, sizeof(cameraData));
                 
                }
				//if (materialSetIndex != index_invalid)
				{
					material->BindTextures(materialSetIndex);
				}
			}
            glm::mat4 m(1.f);
            g_render->SetShaderProperty("u_model", &m, sizeof(m));
			g_render->DrawIndexed(primitive.Count, 1, primitive.FirstIndex);
		}
	}

	void Scene::UpdateRenderData(const RenderContext& renderContext, RenderFrameContext& frameContext)
	{
		CPU_PROFILE_SCOPE(SceneUpdateRenderData);
		if (GetRenderObjectCount())
		{
			// Update geometry
			RecalculateTransforms();
			check(!IsDirty());
			const glm::mat4& viewMat = GetCameraData()->InvView;
			ProcessEnvironmentData(viewMat, m_environmentData);

			index_t offset = 0;
			for (index_t i = 0; i < m_models.GetSize(); ++i)
			{
				index_t count = m_models[i].GetMaterialCount();
				check(offset+count < globals::MaxMaterials);
				m_models[i].UpdateMaterials(m_materials.GetData() + offset);
				m_modelMaterialMap[i] = offset;
				offset += count;
			}

			InitRenderPass();

			//UniformBufferMemoryPool* buffer = frameContext.GlobalBuffer;
			//check(buffer->SetUniform(renderContext, UNIFORM_ID_SCENE_ENV_DATA, &m_environmentData, sizeof(EnvironmentData)));
			//check(buffer->SetUniform(renderContext, UNIFORM_ID_SCENE_MODEL_TRANSFORM_ARRAY, GetRawGlobalTransforms(), GetRenderObjectCount() * sizeof(glm::mat4)));
			//check(buffer->SetDynamicUniform(renderContext, UNIFORM_ID_SCENE_MODEL_TRANSFORM_ARRAY, GetRawGlobalTransforms(), GetRenderObjectCount(), sizeof(glm::mat4), 0));
			//check(buffer->SetDynamicUniform(renderContext, UNIFORM_ID_SCENE_MODEL_TRANSFORM_ARRAY, m_renderTransforms.GetData(), m_renderTransforms.GetSize(), sizeof(glm::mat4), 0));
			//check(buffer->SetDynamicUniform(renderContext, "u_material", m_materials.GetData(), m_materials.GetSize(), sizeof(sMaterialRenderData), 0));
		}
	}

	const glm::mat4* Scene::GetRawGlobalTransforms() const
	{
		check(!IsDirty());
		return m_globalTransforms.GetData();
	}


	void Scene::ProcessEnvironmentData(const glm::mat4& viewSpace, EnvironmentData& environmentData)
	{
		CPU_PROFILE_SCOPE(ProcessEnvData);
		environmentData.ViewPosition = math::GetPos(glm::inverse(viewSpace));
		environmentData.AmbientColor = m_ambientColor;
		environmentData.ActiveLightsCount = 0;
		environmentData.ActiveSpotLightsCount = 0;
		uint32_t shadowMapIndex = 0;
		for (uint32_t i = 0; i < GetRenderObjectCount(); ++i)
		{
			if (m_lightComponentMap.contains(i))
			{
				const glm::mat4& mat = m_globalTransforms[i];
				const glm::vec3 pos = math::GetPos(viewSpace * mat);
				const glm::vec3 dir = -1.f*math::GetDir(viewSpace * mat);
				const LightComponent& light = m_lightComponentMap[i];
				switch (light.Type)
				{
				case ELightType::Point:
				{
					if (environmentData.ActiveLightsCount < EnvironmentData::MaxLights)
					{
						LightData& data = environmentData.Lights[(uint32_t)environmentData.ActiveLightsCount++];
						data.Color = light.Color;
						data.Compression = light.Compression;
						data.Position = pos;
						data.Radius = light.Radius;
					}
					else
						logferror("Too many point lights in scene. Current MaxLights is %d.\n", EnvironmentData::MaxLights);
				}
					break;
				case ELightType::Directional:
					environmentData.DirectionalLight.Color = light.Color;
					environmentData.DirectionalLight.ShadowMapIndex = light.ProjectShadows ? shadowMapIndex++ : -1;
					environmentData.DirectionalLight.Direction = dir;
					break;
				case ELightType::Spot:
				{
					if (environmentData.ActiveSpotLightsCount < EnvironmentData::MaxLights)
					{
						LightData& data = environmentData.SpotLights[(uint32_t)environmentData.ActiveSpotLightsCount++];
						data.Color = light.Color;
						data.ShadowMapIndex = light.ProjectShadows ? shadowMapIndex++ : -1;
						data.Position = pos;
						data.Direction = dir;
						data.CosCutoff.y = cosf(glm::radians(light.OuterCutoff));
						data.CosCutoff.x = cosf(glm::radians(light.Cutoff));
						data.Radius = light.Radius;
						data.Compression = light.Compression;
					}
					else
                        logferror("Too many spot lights in scene. Current MaxLights is %d.\n", EnvironmentData::MaxLights);
				}
					break;
				}
			}
		}
		check(shadowMapIndex <= globals::MaxShadowMapAttachments);
	}

	void tDrawList::SubmitRenderPrimitive(const cMesh* mesh, index_t primitiveIndex, index_t transformIndex, index_t materialIndex)
	{
		check(mesh && primitiveIndex < mesh->primitiveArray.GetSize());
		if (mesh->primitiveArray[primitiveIndex].RenderFlags & RenderFlags)
		{
			Items.Push({
				.TransformIndex = transformIndex,
				.MaterialIndex = materialIndex,
				.PrimitiveIndex = primitiveIndex,
				.Mesh = mesh,
				});
		}
	}
}

