#pragma once
// Autogenerated code for Mist project
// Header file

//#include "Render/VulkanRenderEngine.h"
#include "Render/VulkanBuffer.h"
#include "Render/Texture.h"
#include "Render/Globals.h"
#include "Render/RenderProcesses/Preprocesses.h"
#include "Render/RenderAPI.h"
#include "Render/Model.h"
#include "Render/Material.h"
#include "Core/Types.h"
#include <glm/glm.hpp>
#include "Utils/Angles.h"
#include "Utils/FileSystem.h"
#include "Render/Camera.h"

#define MIST_MAX_MODELS 128
#define MIST_MAX_CAMERAS 4

namespace Mist
{
	struct RenderContext;
	struct RenderFrameContext;
	class IRenderEngine;
	class ShaderProgram;
	class DescriptorLayoutCache;
	class DescriptorAllocator;
	class cTexture;
	class cModel;

	struct sRenderObject
	{
		index_t Id = index_invalid;
		sRenderObject() {}
		sRenderObject(index_t v) : Id(v) {}
		operator index_t() const { return Id; }
		inline bool IsValid() const { return Id != index_invalid; }
	};


	enum class ELightType
	{
		Point,
		Directional,
		Spot
	};

	const char* LightTypeToStr(ELightType);
	ELightType StrToLightType(const char* str);

	struct LightComponent
	{
		ELightType Type = ELightType::Point;
		glm::vec3 Color = { 1.f, 1.f, 1.f };
		float Radius = 10.f;
		float Compression = 1.f;
		float OuterCutoff = 30.f;	// Degrees
		float Cutoff = 30.f;			// Degrees
		bool ProjectShadows = false;
	};

	struct MeshComponent
	{
		char MeshAssetPath[256];
		uint32_t MeshIndex;

		MeshComponent() : MeshIndex(UINT32_MAX) { *MeshAssetPath = 0; }
	};

	struct CameraComponent
	{
		bool Main;
		index_t CameraIndex;

		CameraComponent() : Main(false), CameraIndex(index_invalid) {}
		CameraComponent(index_t i) : Main(false), CameraIndex(i) {}
	};

	struct Hierarchy
	{
		sRenderObject Parent;
		sRenderObject Sibling;
		sRenderObject Child;
		int32_t Level = 0;
	};

	struct TransformComponent
	{
		glm::vec3 Position;
		tAngles Rotation;
		glm::vec3 Scale;
	};

	void TransformComponentToMatrix(const TransformComponent* transforms, glm::mat4* matrices, uint32_t count);

	struct LightData
	{
		glm::vec3 Color;
		float Compression;

		glm::vec3 Position;
		float Radius;

		glm::vec3 Direction;
		int Type;

		glm::vec2 CosCutoff;
		int ShadowMapIndex;
		float _padding;
	};

	struct tShadowMapData
	{
		glm::mat4 LightViewMatrices[globals::MaxShadowMapAttachments];
	};

	struct EnvironmentData
	{
		glm::vec3 AmbientColor;
		int ActiveSpotLightsCount;
		glm::vec3 ViewPosition;
		int ActiveLightsCount;
		static constexpr uint32_t MaxLights = 8;
		LightData Lights[MaxLights];
		LightData DirectionalLight;
		LightData SpotLights[MaxLights];

		EnvironmentData();
	};

	struct CameraData
	{
		glm::mat4 InvView;
		glm::mat4 Projection;
		glm::mat4 ViewProjection;
	};

	struct tViewRenderInfo
	{
		// View info
		CameraData view;

		// Shadow map
		uint32_t shadowMapTexturesSlot;
		tShadowMapData shadowMap;
		render::TextureHandle shadowMapTextures[globals::MaxShadowMapAttachments];

		// Scene info
		EnvironmentData environment;

		uint32_t cubemapSlot;
		const cTexture* cubemap;
		render::TextureHandle cubemapTex;

		// Render flags
		uint16_t flags;
	};

	struct tDrawListItem
	{
		index_t TransformIndex = index_invalid;
		index_t MaterialIndex = index_invalid;
		index_t PrimitiveIndex = index_invalid;
		const cMesh* Mesh = nullptr;
	};
	
	struct tDrawList
	{
		uint32_t RenderFlags;
		tFixedHeapArray<tDrawListItem> Items;

		void SubmitRenderPrimitive(const cMesh* mesh, index_t primitiveIndex, index_t transformOffset, index_t materialIndex);
	};

	struct Skybox
	{
		enum
		{
			FRONT, 
			BACK, 
			TOP, 
			BOTTOM,
			RIGHT, 
			LEFT, 
			COUNT
		};
		render::TextureHandle texture;
		char CubemapFiles[COUNT][256];

		Skybox()
		{ 
			texture = nullptr;
			for (uint32_t i = 0; i < COUNT; ++i)
				*CubemapFiles[i] = 0;
		}
	};

	struct IrradianceCube
	{
		render::TextureHandle cubemap;
		render::TextureHandle irradiance;
		cAssetPath filepath;
	};

	class Scene
	{
	protected:
		Scene(const Scene&) = delete;
		Scene(Scene&&) = delete;
		void operator=(const Scene&) = delete;
		void operator=(Scene&&) = delete;
	public:
		Scene(IRenderEngine* engine);
		~Scene();

		void Init();
		void Destroy();

		void InitFrameData(const RenderContext& renderContext, RenderFrameContext& frameContext);
		void Tick(float deltaTime);

		const CameraController& GetCamera() const;
		CameraController& GetCamera();

		void LoadScene(const RenderContext& context, const char* filepath);
		void SaveScene(const RenderContext& context, const char* filepath);

		sRenderObject CreateRenderObject(sRenderObject parent);
		void DestroyRenderObject(sRenderObject object);
		bool IsValid(sRenderObject object) const;
		uint32_t GetRenderObjectCount() const;

		sRenderObject GetRoot() const;

		const MeshComponent* GetMesh(sRenderObject renderObject) const;
		void SetMesh(sRenderObject renderObject, const MeshComponent& meshComponent);

		const char* GetRenderObjectName(sRenderObject object) const;
		void SetRenderObjectName(sRenderObject renderObject, const char* name);

		const TransformComponent& GetTransform(sRenderObject renderObject) const;
		void SetTransform(sRenderObject renderObject, const TransformComponent& transform);

		const LightComponent* GetLight(sRenderObject renderObject) const;
		void SetLight(sRenderObject renderObject, const LightComponent& light);

		void MarkAsDirty(sRenderObject renderObject);

		const glm::mat4* GetRawGlobalTransforms() const;

		void UpdateRenderData();
		
		void Draw(rendersystem::RenderSystem* renderSystem, uint16_t renderFlags = 0) const;
		void DrawGeometry(rendersystem::RenderSystem* renderSystem, uint16_t renderFlags = 0) const;
		// can be nullptr
		render::TextureHandle GetSkyboxTexture() const;
		void SetSkyboxTexture(const render::TextureHandle& t) { m_skybox.texture = t; }
		const IrradianceCube& GetIrradianceCube() const { return m_irradianceCube; }

		void ImGuiDraw();
		bool IsDirty() const;
		const EnvironmentData& GetEnvironmentData() const { return m_environmentData; }

		void InitRenderPass();
		void PushRenderPipeline(uint32_t pipelineFlags);
		const tDrawList* FindRenderPipeline(uint32_t pipelineFlags) const;
		void DestroyRenderLists();
		void ClearDrawLists();

		void RenderPipelineDraw(const RenderContext& context, uint32_t pipelineFlags, index_t materialSetIndex = index_invalid, rendersystem::ShaderProgram* program = nullptr);

	protected:
		void ProcessEnvironmentData(const glm::mat4& viewMatrix, EnvironmentData& environmentData);
		void RecalculateTransforms();
		bool LoadSkybox(const RenderContext& context, Skybox& skybox, const char* front, const char* back, const char* left, const char* right, const char* top, const char* bottom);
		bool LoadIrradianceCube(const char* filepath);

		const cModel* GetModel(const char* modelName) const { return const_cast<Scene*>(this)->GetModel(modelName); }
		cModel* GetModel(const char* modelName);
		index_t LoadModel(const RenderContext& context, const char* filepath);

		index_t NewCamera();
		void SetCamera(sRenderObject r, const CameraComponent& cameraIndex);

		void PrepareMeshToDraw(rendersystem::RenderSystem* renderSystem, const cModel& model, uint32_t meshIndex, uint32_t transformOffset) const;

	private:
		class VulkanRenderEngine* m_engine{nullptr};
		static constexpr index_t MaxNodeLevel = 16;
		cAssetPath m_sceneFile;
		tFixedHeapArray<String> m_names;
		tFixedHeapArray<Hierarchy> m_hierarchy;
		tFixedHeapArray<TransformComponent> m_transformComponents;
		tMap<index_t, MeshComponent> m_meshComponentMap;
		tMap<index_t, LightComponent> m_lightComponentMap;
		tMap<index_t, CameraComponent> m_cameraComponentMap;

		tStaticArray<cModel, MIST_MAX_MODELS> m_models;
		tStaticArray<CameraController, MIST_MAX_CAMERAS> m_cameras;

		tFixedHeapArray<glm::mat4> m_localTransforms;
		tFixedHeapArray<glm::mat4> m_globalTransforms;
		tFixedHeapArray<glm::mat4> m_renderTransforms;
		tFixedHeapArray<sMaterialRenderData> m_materials;
		tMap<index_t, index_t> m_modelMaterialMap;
		index_t m_editingModel = index_invalid;
		
		tFixedHeapArray<index_t> m_dirtyNodes[MaxNodeLevel];

		glm::vec3 m_ambientColor = {0.05f, 0.05f, 0.05f};

		Skybox m_skybox;
		IrradianceCube m_irradianceCube;
		EnvironmentData m_environmentData;
		tStaticArray<tDrawList, 4> m_drawListArray;

		index_t m_cameraIndex = index_invalid;
	};
}
